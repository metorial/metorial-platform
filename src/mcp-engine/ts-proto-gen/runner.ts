// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v6.31.1
// source: runner.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  type ChannelCredentials,
  Client,
  type ClientDuplexStream,
  type ClientOptions,
  type ClientUnaryCall,
  type handleBidiStreamingCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  type Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import Long from "long";
import { Empty } from "./common";
import { McpError, McpMessageRaw, McpOutput } from "./mcp";
import { WorkerInfoResponse } from "./worker";

export const protobufPackage = "broker.runner";

export interface RunnerInfoRequest {
}

export interface RunnerInfoResponse {
  runnerId: string;
  activeRuns: number;
  totalRuns: Long;
  workerInfo: WorkerInfoResponse | undefined;
}

export interface ActiveRunsResponse {
  runs: RunInfo[];
}

export interface RunInfo {
  runId: string;
  dockerImage: string;
  /** e.g., "512m" or "1g" */
  maxMemory: string;
  /** e.g., "1" */
  maxCpu: string;
  startTime: Long;
  endTime: Long;
}

export interface DockerImagesResponse {
  images: DockerImageInfo[];
}

export interface DockerImageInfo {
  repository: string;
  tag: string;
  imageId: string;
}

export interface DockerContainersResponse {
  containers: DockerContainerInfo[];
}

export interface DockerContainerInfo {
  containerId: string;
  imageRepository: string;
  imageTag: string;
  exitCode: number;
  running: boolean;
}

export interface RunConfigContainerArguments {
  command: string;
  envVars: { [key: string]: string };
  args: string[];
}

export interface RunConfigContainerArguments_EnvVarsEntry {
  key: string;
  value: string;
}

export interface RunConfigContainer {
  dockerImage: string;
  /** e.g., "512m" or "1g" */
  maxMemory: string;
  /** e.g., "1" */
  maxCpu: string;
}

export interface RunConfig {
  container: RunConfigContainer | undefined;
  arguments: RunConfigContainerArguments | undefined;
}

export interface RunRequest {
  init?: RunRequestInit | undefined;
  mcpMessage?: RunRequestMcpMessage | undefined;
  close?: RunRequestClose | undefined;
}

export interface RunRequestInit {
  /** Unique identifier for the run */
  connectionId: string;
  runConfig: RunConfig | undefined;
}

export interface RunRequestMcpMessage {
  message: McpMessageRaw | undefined;
}

export interface RunRequestClose {
}

export interface RunResponse {
  mcpMessage?: RunResponseMcpMessage | undefined;
  init?: RunResponseInit | undefined;
  output?: RunResponseOutput | undefined;
  error?: RunResponseError | undefined;
  close?: RunResponseClose | undefined;
}

export interface RunResponseInit {
}

export interface RunResponseMcpMessage {
  message: McpMessageRaw | undefined;
}

export interface RunResponseError {
  mcpError: McpError | undefined;
}

export interface RunResponseOutput {
  mcpOutput: McpOutput | undefined;
}

export interface RunResponseClose {
}

function createBaseRunnerInfoRequest(): RunnerInfoRequest {
  return {};
}

export const RunnerInfoRequest: MessageFns<RunnerInfoRequest> = {
  encode(_: RunnerInfoRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunnerInfoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunnerInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RunnerInfoRequest {
    return {};
  },

  toJSON(_: RunnerInfoRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<RunnerInfoRequest>): RunnerInfoRequest {
    return RunnerInfoRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<RunnerInfoRequest>): RunnerInfoRequest {
    const message = createBaseRunnerInfoRequest();
    return message;
  },
};

function createBaseRunnerInfoResponse(): RunnerInfoResponse {
  return { runnerId: "", activeRuns: 0, totalRuns: Long.UZERO, workerInfo: undefined };
}

export const RunnerInfoResponse: MessageFns<RunnerInfoResponse> = {
  encode(message: RunnerInfoResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.runnerId !== "") {
      writer.uint32(10).string(message.runnerId);
    }
    if (message.activeRuns !== 0) {
      writer.uint32(16).uint32(message.activeRuns);
    }
    if (!message.totalRuns.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.totalRuns.toString());
    }
    if (message.workerInfo !== undefined) {
      WorkerInfoResponse.encode(message.workerInfo, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunnerInfoResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunnerInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.runnerId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.activeRuns = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.totalRuns = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.workerInfo = WorkerInfoResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunnerInfoResponse {
    return {
      runnerId: isSet(object.runnerId) ? globalThis.String(object.runnerId) : "",
      activeRuns: isSet(object.activeRuns) ? globalThis.Number(object.activeRuns) : 0,
      totalRuns: isSet(object.totalRuns) ? Long.fromValue(object.totalRuns) : Long.UZERO,
      workerInfo: isSet(object.workerInfo) ? WorkerInfoResponse.fromJSON(object.workerInfo) : undefined,
    };
  },

  toJSON(message: RunnerInfoResponse): unknown {
    const obj: any = {};
    if (message.runnerId !== "") {
      obj.runnerId = message.runnerId;
    }
    if (message.activeRuns !== 0) {
      obj.activeRuns = Math.round(message.activeRuns);
    }
    if (!message.totalRuns.equals(Long.UZERO)) {
      obj.totalRuns = (message.totalRuns || Long.UZERO).toString();
    }
    if (message.workerInfo !== undefined) {
      obj.workerInfo = WorkerInfoResponse.toJSON(message.workerInfo);
    }
    return obj;
  },

  create(base?: DeepPartial<RunnerInfoResponse>): RunnerInfoResponse {
    return RunnerInfoResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RunnerInfoResponse>): RunnerInfoResponse {
    const message = createBaseRunnerInfoResponse();
    message.runnerId = object.runnerId ?? "";
    message.activeRuns = object.activeRuns ?? 0;
    message.totalRuns = (object.totalRuns !== undefined && object.totalRuns !== null)
      ? Long.fromValue(object.totalRuns)
      : Long.UZERO;
    message.workerInfo = (object.workerInfo !== undefined && object.workerInfo !== null)
      ? WorkerInfoResponse.fromPartial(object.workerInfo)
      : undefined;
    return message;
  },
};

function createBaseActiveRunsResponse(): ActiveRunsResponse {
  return { runs: [] };
}

export const ActiveRunsResponse: MessageFns<ActiveRunsResponse> = {
  encode(message: ActiveRunsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.runs) {
      RunInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ActiveRunsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActiveRunsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.runs.push(RunInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ActiveRunsResponse {
    return { runs: globalThis.Array.isArray(object?.runs) ? object.runs.map((e: any) => RunInfo.fromJSON(e)) : [] };
  },

  toJSON(message: ActiveRunsResponse): unknown {
    const obj: any = {};
    if (message.runs?.length) {
      obj.runs = message.runs.map((e) => RunInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ActiveRunsResponse>): ActiveRunsResponse {
    return ActiveRunsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ActiveRunsResponse>): ActiveRunsResponse {
    const message = createBaseActiveRunsResponse();
    message.runs = object.runs?.map((e) => RunInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRunInfo(): RunInfo {
  return { runId: "", dockerImage: "", maxMemory: "", maxCpu: "", startTime: Long.ZERO, endTime: Long.ZERO };
}

export const RunInfo: MessageFns<RunInfo> = {
  encode(message: RunInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.runId !== "") {
      writer.uint32(10).string(message.runId);
    }
    if (message.dockerImage !== "") {
      writer.uint32(18).string(message.dockerImage);
    }
    if (message.maxMemory !== "") {
      writer.uint32(50).string(message.maxMemory);
    }
    if (message.maxCpu !== "") {
      writer.uint32(58).string(message.maxCpu);
    }
    if (!message.startTime.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.startTime.toString());
    }
    if (!message.endTime.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.endTime.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.runId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.dockerImage = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.maxMemory = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.maxCpu = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.startTime = Long.fromString(reader.int64().toString());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.endTime = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunInfo {
    return {
      runId: isSet(object.runId) ? globalThis.String(object.runId) : "",
      dockerImage: isSet(object.dockerImage) ? globalThis.String(object.dockerImage) : "",
      maxMemory: isSet(object.maxMemory) ? globalThis.String(object.maxMemory) : "",
      maxCpu: isSet(object.maxCpu) ? globalThis.String(object.maxCpu) : "",
      startTime: isSet(object.startTime) ? Long.fromValue(object.startTime) : Long.ZERO,
      endTime: isSet(object.endTime) ? Long.fromValue(object.endTime) : Long.ZERO,
    };
  },

  toJSON(message: RunInfo): unknown {
    const obj: any = {};
    if (message.runId !== "") {
      obj.runId = message.runId;
    }
    if (message.dockerImage !== "") {
      obj.dockerImage = message.dockerImage;
    }
    if (message.maxMemory !== "") {
      obj.maxMemory = message.maxMemory;
    }
    if (message.maxCpu !== "") {
      obj.maxCpu = message.maxCpu;
    }
    if (!message.startTime.equals(Long.ZERO)) {
      obj.startTime = (message.startTime || Long.ZERO).toString();
    }
    if (!message.endTime.equals(Long.ZERO)) {
      obj.endTime = (message.endTime || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<RunInfo>): RunInfo {
    return RunInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RunInfo>): RunInfo {
    const message = createBaseRunInfo();
    message.runId = object.runId ?? "";
    message.dockerImage = object.dockerImage ?? "";
    message.maxMemory = object.maxMemory ?? "";
    message.maxCpu = object.maxCpu ?? "";
    message.startTime = (object.startTime !== undefined && object.startTime !== null)
      ? Long.fromValue(object.startTime)
      : Long.ZERO;
    message.endTime = (object.endTime !== undefined && object.endTime !== null)
      ? Long.fromValue(object.endTime)
      : Long.ZERO;
    return message;
  },
};

function createBaseDockerImagesResponse(): DockerImagesResponse {
  return { images: [] };
}

export const DockerImagesResponse: MessageFns<DockerImagesResponse> = {
  encode(message: DockerImagesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.images) {
      DockerImageInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DockerImagesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDockerImagesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.images.push(DockerImageInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DockerImagesResponse {
    return {
      images: globalThis.Array.isArray(object?.images)
        ? object.images.map((e: any) => DockerImageInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: DockerImagesResponse): unknown {
    const obj: any = {};
    if (message.images?.length) {
      obj.images = message.images.map((e) => DockerImageInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<DockerImagesResponse>): DockerImagesResponse {
    return DockerImagesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DockerImagesResponse>): DockerImagesResponse {
    const message = createBaseDockerImagesResponse();
    message.images = object.images?.map((e) => DockerImageInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDockerImageInfo(): DockerImageInfo {
  return { repository: "", tag: "", imageId: "" };
}

export const DockerImageInfo: MessageFns<DockerImageInfo> = {
  encode(message: DockerImageInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.repository !== "") {
      writer.uint32(10).string(message.repository);
    }
    if (message.tag !== "") {
      writer.uint32(18).string(message.tag);
    }
    if (message.imageId !== "") {
      writer.uint32(26).string(message.imageId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DockerImageInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDockerImageInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.repository = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.tag = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.imageId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DockerImageInfo {
    return {
      repository: isSet(object.repository) ? globalThis.String(object.repository) : "",
      tag: isSet(object.tag) ? globalThis.String(object.tag) : "",
      imageId: isSet(object.imageId) ? globalThis.String(object.imageId) : "",
    };
  },

  toJSON(message: DockerImageInfo): unknown {
    const obj: any = {};
    if (message.repository !== "") {
      obj.repository = message.repository;
    }
    if (message.tag !== "") {
      obj.tag = message.tag;
    }
    if (message.imageId !== "") {
      obj.imageId = message.imageId;
    }
    return obj;
  },

  create(base?: DeepPartial<DockerImageInfo>): DockerImageInfo {
    return DockerImageInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DockerImageInfo>): DockerImageInfo {
    const message = createBaseDockerImageInfo();
    message.repository = object.repository ?? "";
    message.tag = object.tag ?? "";
    message.imageId = object.imageId ?? "";
    return message;
  },
};

function createBaseDockerContainersResponse(): DockerContainersResponse {
  return { containers: [] };
}

export const DockerContainersResponse: MessageFns<DockerContainersResponse> = {
  encode(message: DockerContainersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.containers) {
      DockerContainerInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DockerContainersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDockerContainersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.containers.push(DockerContainerInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DockerContainersResponse {
    return {
      containers: globalThis.Array.isArray(object?.containers)
        ? object.containers.map((e: any) => DockerContainerInfo.fromJSON(e))
        : [],
    };
  },

  toJSON(message: DockerContainersResponse): unknown {
    const obj: any = {};
    if (message.containers?.length) {
      obj.containers = message.containers.map((e) => DockerContainerInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<DockerContainersResponse>): DockerContainersResponse {
    return DockerContainersResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DockerContainersResponse>): DockerContainersResponse {
    const message = createBaseDockerContainersResponse();
    message.containers = object.containers?.map((e) => DockerContainerInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseDockerContainerInfo(): DockerContainerInfo {
  return { containerId: "", imageRepository: "", imageTag: "", exitCode: 0, running: false };
}

export const DockerContainerInfo: MessageFns<DockerContainerInfo> = {
  encode(message: DockerContainerInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.containerId !== "") {
      writer.uint32(10).string(message.containerId);
    }
    if (message.imageRepository !== "") {
      writer.uint32(18).string(message.imageRepository);
    }
    if (message.imageTag !== "") {
      writer.uint32(42).string(message.imageTag);
    }
    if (message.exitCode !== 0) {
      writer.uint32(24).int32(message.exitCode);
    }
    if (message.running !== false) {
      writer.uint32(32).bool(message.running);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DockerContainerInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDockerContainerInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.containerId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.imageRepository = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.imageTag = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.exitCode = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.running = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DockerContainerInfo {
    return {
      containerId: isSet(object.containerId) ? globalThis.String(object.containerId) : "",
      imageRepository: isSet(object.imageRepository) ? globalThis.String(object.imageRepository) : "",
      imageTag: isSet(object.imageTag) ? globalThis.String(object.imageTag) : "",
      exitCode: isSet(object.exitCode) ? globalThis.Number(object.exitCode) : 0,
      running: isSet(object.running) ? globalThis.Boolean(object.running) : false,
    };
  },

  toJSON(message: DockerContainerInfo): unknown {
    const obj: any = {};
    if (message.containerId !== "") {
      obj.containerId = message.containerId;
    }
    if (message.imageRepository !== "") {
      obj.imageRepository = message.imageRepository;
    }
    if (message.imageTag !== "") {
      obj.imageTag = message.imageTag;
    }
    if (message.exitCode !== 0) {
      obj.exitCode = Math.round(message.exitCode);
    }
    if (message.running !== false) {
      obj.running = message.running;
    }
    return obj;
  },

  create(base?: DeepPartial<DockerContainerInfo>): DockerContainerInfo {
    return DockerContainerInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DockerContainerInfo>): DockerContainerInfo {
    const message = createBaseDockerContainerInfo();
    message.containerId = object.containerId ?? "";
    message.imageRepository = object.imageRepository ?? "";
    message.imageTag = object.imageTag ?? "";
    message.exitCode = object.exitCode ?? 0;
    message.running = object.running ?? false;
    return message;
  },
};

function createBaseRunConfigContainerArguments(): RunConfigContainerArguments {
  return { command: "", envVars: {}, args: [] };
}

export const RunConfigContainerArguments: MessageFns<RunConfigContainerArguments> = {
  encode(message: RunConfigContainerArguments, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.command !== "") {
      writer.uint32(10).string(message.command);
    }
    Object.entries(message.envVars).forEach(([key, value]) => {
      RunConfigContainerArguments_EnvVarsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    for (const v of message.args) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunConfigContainerArguments {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunConfigContainerArguments();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.command = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = RunConfigContainerArguments_EnvVarsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.envVars[entry2.key] = entry2.value;
          }
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.args.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunConfigContainerArguments {
    return {
      command: isSet(object.command) ? globalThis.String(object.command) : "",
      envVars: isObject(object.envVars)
        ? Object.entries(object.envVars).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      args: globalThis.Array.isArray(object?.args) ? object.args.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: RunConfigContainerArguments): unknown {
    const obj: any = {};
    if (message.command !== "") {
      obj.command = message.command;
    }
    if (message.envVars) {
      const entries = Object.entries(message.envVars);
      if (entries.length > 0) {
        obj.envVars = {};
        entries.forEach(([k, v]) => {
          obj.envVars[k] = v;
        });
      }
    }
    if (message.args?.length) {
      obj.args = message.args;
    }
    return obj;
  },

  create(base?: DeepPartial<RunConfigContainerArguments>): RunConfigContainerArguments {
    return RunConfigContainerArguments.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RunConfigContainerArguments>): RunConfigContainerArguments {
    const message = createBaseRunConfigContainerArguments();
    message.command = object.command ?? "";
    message.envVars = Object.entries(object.envVars ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.args = object.args?.map((e) => e) || [];
    return message;
  },
};

function createBaseRunConfigContainerArguments_EnvVarsEntry(): RunConfigContainerArguments_EnvVarsEntry {
  return { key: "", value: "" };
}

export const RunConfigContainerArguments_EnvVarsEntry: MessageFns<RunConfigContainerArguments_EnvVarsEntry> = {
  encode(message: RunConfigContainerArguments_EnvVarsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunConfigContainerArguments_EnvVarsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunConfigContainerArguments_EnvVarsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunConfigContainerArguments_EnvVarsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: RunConfigContainerArguments_EnvVarsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<RunConfigContainerArguments_EnvVarsEntry>): RunConfigContainerArguments_EnvVarsEntry {
    return RunConfigContainerArguments_EnvVarsEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RunConfigContainerArguments_EnvVarsEntry>): RunConfigContainerArguments_EnvVarsEntry {
    const message = createBaseRunConfigContainerArguments_EnvVarsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseRunConfigContainer(): RunConfigContainer {
  return { dockerImage: "", maxMemory: "", maxCpu: "" };
}

export const RunConfigContainer: MessageFns<RunConfigContainer> = {
  encode(message: RunConfigContainer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.dockerImage !== "") {
      writer.uint32(10).string(message.dockerImage);
    }
    if (message.maxMemory !== "") {
      writer.uint32(18).string(message.maxMemory);
    }
    if (message.maxCpu !== "") {
      writer.uint32(26).string(message.maxCpu);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunConfigContainer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunConfigContainer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.dockerImage = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.maxMemory = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.maxCpu = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunConfigContainer {
    return {
      dockerImage: isSet(object.dockerImage) ? globalThis.String(object.dockerImage) : "",
      maxMemory: isSet(object.maxMemory) ? globalThis.String(object.maxMemory) : "",
      maxCpu: isSet(object.maxCpu) ? globalThis.String(object.maxCpu) : "",
    };
  },

  toJSON(message: RunConfigContainer): unknown {
    const obj: any = {};
    if (message.dockerImage !== "") {
      obj.dockerImage = message.dockerImage;
    }
    if (message.maxMemory !== "") {
      obj.maxMemory = message.maxMemory;
    }
    if (message.maxCpu !== "") {
      obj.maxCpu = message.maxCpu;
    }
    return obj;
  },

  create(base?: DeepPartial<RunConfigContainer>): RunConfigContainer {
    return RunConfigContainer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RunConfigContainer>): RunConfigContainer {
    const message = createBaseRunConfigContainer();
    message.dockerImage = object.dockerImage ?? "";
    message.maxMemory = object.maxMemory ?? "";
    message.maxCpu = object.maxCpu ?? "";
    return message;
  },
};

function createBaseRunConfig(): RunConfig {
  return { container: undefined, arguments: undefined };
}

export const RunConfig: MessageFns<RunConfig> = {
  encode(message: RunConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.container !== undefined) {
      RunConfigContainer.encode(message.container, writer.uint32(10).fork()).join();
    }
    if (message.arguments !== undefined) {
      RunConfigContainerArguments.encode(message.arguments, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.container = RunConfigContainer.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.arguments = RunConfigContainerArguments.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunConfig {
    return {
      container: isSet(object.container) ? RunConfigContainer.fromJSON(object.container) : undefined,
      arguments: isSet(object.arguments) ? RunConfigContainerArguments.fromJSON(object.arguments) : undefined,
    };
  },

  toJSON(message: RunConfig): unknown {
    const obj: any = {};
    if (message.container !== undefined) {
      obj.container = RunConfigContainer.toJSON(message.container);
    }
    if (message.arguments !== undefined) {
      obj.arguments = RunConfigContainerArguments.toJSON(message.arguments);
    }
    return obj;
  },

  create(base?: DeepPartial<RunConfig>): RunConfig {
    return RunConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RunConfig>): RunConfig {
    const message = createBaseRunConfig();
    message.container = (object.container !== undefined && object.container !== null)
      ? RunConfigContainer.fromPartial(object.container)
      : undefined;
    message.arguments = (object.arguments !== undefined && object.arguments !== null)
      ? RunConfigContainerArguments.fromPartial(object.arguments)
      : undefined;
    return message;
  },
};

function createBaseRunRequest(): RunRequest {
  return { init: undefined, mcpMessage: undefined, close: undefined };
}

export const RunRequest: MessageFns<RunRequest> = {
  encode(message: RunRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.init !== undefined) {
      RunRequestInit.encode(message.init, writer.uint32(10).fork()).join();
    }
    if (message.mcpMessage !== undefined) {
      RunRequestMcpMessage.encode(message.mcpMessage, writer.uint32(18).fork()).join();
    }
    if (message.close !== undefined) {
      RunRequestClose.encode(message.close, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.init = RunRequestInit.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.mcpMessage = RunRequestMcpMessage.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.close = RunRequestClose.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunRequest {
    return {
      init: isSet(object.init) ? RunRequestInit.fromJSON(object.init) : undefined,
      mcpMessage: isSet(object.mcpMessage) ? RunRequestMcpMessage.fromJSON(object.mcpMessage) : undefined,
      close: isSet(object.close) ? RunRequestClose.fromJSON(object.close) : undefined,
    };
  },

  toJSON(message: RunRequest): unknown {
    const obj: any = {};
    if (message.init !== undefined) {
      obj.init = RunRequestInit.toJSON(message.init);
    }
    if (message.mcpMessage !== undefined) {
      obj.mcpMessage = RunRequestMcpMessage.toJSON(message.mcpMessage);
    }
    if (message.close !== undefined) {
      obj.close = RunRequestClose.toJSON(message.close);
    }
    return obj;
  },

  create(base?: DeepPartial<RunRequest>): RunRequest {
    return RunRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RunRequest>): RunRequest {
    const message = createBaseRunRequest();
    message.init = (object.init !== undefined && object.init !== null)
      ? RunRequestInit.fromPartial(object.init)
      : undefined;
    message.mcpMessage = (object.mcpMessage !== undefined && object.mcpMessage !== null)
      ? RunRequestMcpMessage.fromPartial(object.mcpMessage)
      : undefined;
    message.close = (object.close !== undefined && object.close !== null)
      ? RunRequestClose.fromPartial(object.close)
      : undefined;
    return message;
  },
};

function createBaseRunRequestInit(): RunRequestInit {
  return { connectionId: "", runConfig: undefined };
}

export const RunRequestInit: MessageFns<RunRequestInit> = {
  encode(message: RunRequestInit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.connectionId !== "") {
      writer.uint32(10).string(message.connectionId);
    }
    if (message.runConfig !== undefined) {
      RunConfig.encode(message.runConfig, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunRequestInit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunRequestInit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.connectionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.runConfig = RunConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunRequestInit {
    return {
      connectionId: isSet(object.connectionId) ? globalThis.String(object.connectionId) : "",
      runConfig: isSet(object.runConfig) ? RunConfig.fromJSON(object.runConfig) : undefined,
    };
  },

  toJSON(message: RunRequestInit): unknown {
    const obj: any = {};
    if (message.connectionId !== "") {
      obj.connectionId = message.connectionId;
    }
    if (message.runConfig !== undefined) {
      obj.runConfig = RunConfig.toJSON(message.runConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<RunRequestInit>): RunRequestInit {
    return RunRequestInit.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RunRequestInit>): RunRequestInit {
    const message = createBaseRunRequestInit();
    message.connectionId = object.connectionId ?? "";
    message.runConfig = (object.runConfig !== undefined && object.runConfig !== null)
      ? RunConfig.fromPartial(object.runConfig)
      : undefined;
    return message;
  },
};

function createBaseRunRequestMcpMessage(): RunRequestMcpMessage {
  return { message: undefined };
}

export const RunRequestMcpMessage: MessageFns<RunRequestMcpMessage> = {
  encode(message: RunRequestMcpMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== undefined) {
      McpMessageRaw.encode(message.message, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunRequestMcpMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunRequestMcpMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = McpMessageRaw.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunRequestMcpMessage {
    return { message: isSet(object.message) ? McpMessageRaw.fromJSON(object.message) : undefined };
  },

  toJSON(message: RunRequestMcpMessage): unknown {
    const obj: any = {};
    if (message.message !== undefined) {
      obj.message = McpMessageRaw.toJSON(message.message);
    }
    return obj;
  },

  create(base?: DeepPartial<RunRequestMcpMessage>): RunRequestMcpMessage {
    return RunRequestMcpMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RunRequestMcpMessage>): RunRequestMcpMessage {
    const message = createBaseRunRequestMcpMessage();
    message.message = (object.message !== undefined && object.message !== null)
      ? McpMessageRaw.fromPartial(object.message)
      : undefined;
    return message;
  },
};

function createBaseRunRequestClose(): RunRequestClose {
  return {};
}

export const RunRequestClose: MessageFns<RunRequestClose> = {
  encode(_: RunRequestClose, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunRequestClose {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunRequestClose();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RunRequestClose {
    return {};
  },

  toJSON(_: RunRequestClose): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<RunRequestClose>): RunRequestClose {
    return RunRequestClose.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<RunRequestClose>): RunRequestClose {
    const message = createBaseRunRequestClose();
    return message;
  },
};

function createBaseRunResponse(): RunResponse {
  return { mcpMessage: undefined, init: undefined, output: undefined, error: undefined, close: undefined };
}

export const RunResponse: MessageFns<RunResponse> = {
  encode(message: RunResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mcpMessage !== undefined) {
      RunResponseMcpMessage.encode(message.mcpMessage, writer.uint32(10).fork()).join();
    }
    if (message.init !== undefined) {
      RunResponseInit.encode(message.init, writer.uint32(18).fork()).join();
    }
    if (message.output !== undefined) {
      RunResponseOutput.encode(message.output, writer.uint32(26).fork()).join();
    }
    if (message.error !== undefined) {
      RunResponseError.encode(message.error, writer.uint32(34).fork()).join();
    }
    if (message.close !== undefined) {
      RunResponseClose.encode(message.close, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mcpMessage = RunResponseMcpMessage.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.init = RunResponseInit.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.output = RunResponseOutput.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.error = RunResponseError.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.close = RunResponseClose.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunResponse {
    return {
      mcpMessage: isSet(object.mcpMessage) ? RunResponseMcpMessage.fromJSON(object.mcpMessage) : undefined,
      init: isSet(object.init) ? RunResponseInit.fromJSON(object.init) : undefined,
      output: isSet(object.output) ? RunResponseOutput.fromJSON(object.output) : undefined,
      error: isSet(object.error) ? RunResponseError.fromJSON(object.error) : undefined,
      close: isSet(object.close) ? RunResponseClose.fromJSON(object.close) : undefined,
    };
  },

  toJSON(message: RunResponse): unknown {
    const obj: any = {};
    if (message.mcpMessage !== undefined) {
      obj.mcpMessage = RunResponseMcpMessage.toJSON(message.mcpMessage);
    }
    if (message.init !== undefined) {
      obj.init = RunResponseInit.toJSON(message.init);
    }
    if (message.output !== undefined) {
      obj.output = RunResponseOutput.toJSON(message.output);
    }
    if (message.error !== undefined) {
      obj.error = RunResponseError.toJSON(message.error);
    }
    if (message.close !== undefined) {
      obj.close = RunResponseClose.toJSON(message.close);
    }
    return obj;
  },

  create(base?: DeepPartial<RunResponse>): RunResponse {
    return RunResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RunResponse>): RunResponse {
    const message = createBaseRunResponse();
    message.mcpMessage = (object.mcpMessage !== undefined && object.mcpMessage !== null)
      ? RunResponseMcpMessage.fromPartial(object.mcpMessage)
      : undefined;
    message.init = (object.init !== undefined && object.init !== null)
      ? RunResponseInit.fromPartial(object.init)
      : undefined;
    message.output = (object.output !== undefined && object.output !== null)
      ? RunResponseOutput.fromPartial(object.output)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null)
      ? RunResponseError.fromPartial(object.error)
      : undefined;
    message.close = (object.close !== undefined && object.close !== null)
      ? RunResponseClose.fromPartial(object.close)
      : undefined;
    return message;
  },
};

function createBaseRunResponseInit(): RunResponseInit {
  return {};
}

export const RunResponseInit: MessageFns<RunResponseInit> = {
  encode(_: RunResponseInit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunResponseInit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunResponseInit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RunResponseInit {
    return {};
  },

  toJSON(_: RunResponseInit): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<RunResponseInit>): RunResponseInit {
    return RunResponseInit.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<RunResponseInit>): RunResponseInit {
    const message = createBaseRunResponseInit();
    return message;
  },
};

function createBaseRunResponseMcpMessage(): RunResponseMcpMessage {
  return { message: undefined };
}

export const RunResponseMcpMessage: MessageFns<RunResponseMcpMessage> = {
  encode(message: RunResponseMcpMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== undefined) {
      McpMessageRaw.encode(message.message, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunResponseMcpMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunResponseMcpMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = McpMessageRaw.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunResponseMcpMessage {
    return { message: isSet(object.message) ? McpMessageRaw.fromJSON(object.message) : undefined };
  },

  toJSON(message: RunResponseMcpMessage): unknown {
    const obj: any = {};
    if (message.message !== undefined) {
      obj.message = McpMessageRaw.toJSON(message.message);
    }
    return obj;
  },

  create(base?: DeepPartial<RunResponseMcpMessage>): RunResponseMcpMessage {
    return RunResponseMcpMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RunResponseMcpMessage>): RunResponseMcpMessage {
    const message = createBaseRunResponseMcpMessage();
    message.message = (object.message !== undefined && object.message !== null)
      ? McpMessageRaw.fromPartial(object.message)
      : undefined;
    return message;
  },
};

function createBaseRunResponseError(): RunResponseError {
  return { mcpError: undefined };
}

export const RunResponseError: MessageFns<RunResponseError> = {
  encode(message: RunResponseError, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mcpError !== undefined) {
      McpError.encode(message.mcpError, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunResponseError {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunResponseError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mcpError = McpError.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunResponseError {
    return { mcpError: isSet(object.mcpError) ? McpError.fromJSON(object.mcpError) : undefined };
  },

  toJSON(message: RunResponseError): unknown {
    const obj: any = {};
    if (message.mcpError !== undefined) {
      obj.mcpError = McpError.toJSON(message.mcpError);
    }
    return obj;
  },

  create(base?: DeepPartial<RunResponseError>): RunResponseError {
    return RunResponseError.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RunResponseError>): RunResponseError {
    const message = createBaseRunResponseError();
    message.mcpError = (object.mcpError !== undefined && object.mcpError !== null)
      ? McpError.fromPartial(object.mcpError)
      : undefined;
    return message;
  },
};

function createBaseRunResponseOutput(): RunResponseOutput {
  return { mcpOutput: undefined };
}

export const RunResponseOutput: MessageFns<RunResponseOutput> = {
  encode(message: RunResponseOutput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mcpOutput !== undefined) {
      McpOutput.encode(message.mcpOutput, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunResponseOutput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunResponseOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mcpOutput = McpOutput.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunResponseOutput {
    return { mcpOutput: isSet(object.mcpOutput) ? McpOutput.fromJSON(object.mcpOutput) : undefined };
  },

  toJSON(message: RunResponseOutput): unknown {
    const obj: any = {};
    if (message.mcpOutput !== undefined) {
      obj.mcpOutput = McpOutput.toJSON(message.mcpOutput);
    }
    return obj;
  },

  create(base?: DeepPartial<RunResponseOutput>): RunResponseOutput {
    return RunResponseOutput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RunResponseOutput>): RunResponseOutput {
    const message = createBaseRunResponseOutput();
    message.mcpOutput = (object.mcpOutput !== undefined && object.mcpOutput !== null)
      ? McpOutput.fromPartial(object.mcpOutput)
      : undefined;
    return message;
  },
};

function createBaseRunResponseClose(): RunResponseClose {
  return {};
}

export const RunResponseClose: MessageFns<RunResponseClose> = {
  encode(_: RunResponseClose, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunResponseClose {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunResponseClose();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RunResponseClose {
    return {};
  },

  toJSON(_: RunResponseClose): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<RunResponseClose>): RunResponseClose {
    return RunResponseClose.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<RunResponseClose>): RunResponseClose {
    const message = createBaseRunResponseClose();
    return message;
  },
};

export type McpRunnerService = typeof McpRunnerService;
export const McpRunnerService = {
  getRunnerInfo: {
    path: "/broker.runner.McpRunner/GetRunnerInfo",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RunnerInfoRequest): Buffer => Buffer.from(RunnerInfoRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): RunnerInfoRequest => RunnerInfoRequest.decode(value),
    responseSerialize: (value: RunnerInfoResponse): Buffer => Buffer.from(RunnerInfoResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): RunnerInfoResponse => RunnerInfoResponse.decode(value),
  },
  listActiveRuns: {
    path: "/broker.runner.McpRunner/ListActiveRuns",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer): Empty => Empty.decode(value),
    responseSerialize: (value: ActiveRunsResponse): Buffer => Buffer.from(ActiveRunsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ActiveRunsResponse => ActiveRunsResponse.decode(value),
  },
  listDockerImages: {
    path: "/broker.runner.McpRunner/ListDockerImages",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer): Empty => Empty.decode(value),
    responseSerialize: (value: DockerImagesResponse): Buffer =>
      Buffer.from(DockerImagesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DockerImagesResponse => DockerImagesResponse.decode(value),
  },
  listDockerContainers: {
    path: "/broker.runner.McpRunner/ListDockerContainers",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer): Empty => Empty.decode(value),
    responseSerialize: (value: DockerContainersResponse): Buffer =>
      Buffer.from(DockerContainersResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DockerContainersResponse => DockerContainersResponse.decode(value),
  },
  streamMcpRun: {
    path: "/broker.runner.McpRunner/StreamMcpRun",
    requestStream: true,
    responseStream: true,
    requestSerialize: (value: RunRequest): Buffer => Buffer.from(RunRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): RunRequest => RunRequest.decode(value),
    responseSerialize: (value: RunResponse): Buffer => Buffer.from(RunResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): RunResponse => RunResponse.decode(value),
  },
} as const;

export interface McpRunnerServer extends UntypedServiceImplementation {
  getRunnerInfo: handleUnaryCall<RunnerInfoRequest, RunnerInfoResponse>;
  listActiveRuns: handleUnaryCall<Empty, ActiveRunsResponse>;
  listDockerImages: handleUnaryCall<Empty, DockerImagesResponse>;
  listDockerContainers: handleUnaryCall<Empty, DockerContainersResponse>;
  streamMcpRun: handleBidiStreamingCall<RunRequest, RunResponse>;
}

export interface McpRunnerClient extends Client {
  getRunnerInfo(
    request: RunnerInfoRequest,
    callback: (error: ServiceError | null, response: RunnerInfoResponse) => void,
  ): ClientUnaryCall;
  getRunnerInfo(
    request: RunnerInfoRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: RunnerInfoResponse) => void,
  ): ClientUnaryCall;
  getRunnerInfo(
    request: RunnerInfoRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: RunnerInfoResponse) => void,
  ): ClientUnaryCall;
  listActiveRuns(
    request: Empty,
    callback: (error: ServiceError | null, response: ActiveRunsResponse) => void,
  ): ClientUnaryCall;
  listActiveRuns(
    request: Empty,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ActiveRunsResponse) => void,
  ): ClientUnaryCall;
  listActiveRuns(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ActiveRunsResponse) => void,
  ): ClientUnaryCall;
  listDockerImages(
    request: Empty,
    callback: (error: ServiceError | null, response: DockerImagesResponse) => void,
  ): ClientUnaryCall;
  listDockerImages(
    request: Empty,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DockerImagesResponse) => void,
  ): ClientUnaryCall;
  listDockerImages(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DockerImagesResponse) => void,
  ): ClientUnaryCall;
  listDockerContainers(
    request: Empty,
    callback: (error: ServiceError | null, response: DockerContainersResponse) => void,
  ): ClientUnaryCall;
  listDockerContainers(
    request: Empty,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DockerContainersResponse) => void,
  ): ClientUnaryCall;
  listDockerContainers(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DockerContainersResponse) => void,
  ): ClientUnaryCall;
  streamMcpRun(): ClientDuplexStream<RunRequest, RunResponse>;
  streamMcpRun(options: Partial<CallOptions>): ClientDuplexStream<RunRequest, RunResponse>;
  streamMcpRun(metadata: Metadata, options?: Partial<CallOptions>): ClientDuplexStream<RunRequest, RunResponse>;
}

export const McpRunnerClient = makeGenericClientConstructor(McpRunnerService, "broker.runner.McpRunner") as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): McpRunnerClient;
  service: typeof McpRunnerService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
