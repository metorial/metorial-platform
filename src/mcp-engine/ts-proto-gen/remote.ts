// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.7
//   protoc               v6.32.0
// source: remote.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  type ChannelCredentials,
  Client,
  type ClientDuplexStream,
  type ClientOptions,
  type handleBidiStreamingCall,
  makeGenericClientConstructor,
  type Metadata,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import Long from "long";
import { McpError, McpMessage, McpMessageRaw, McpOutput } from "./mcp";
import { WorkerInfoResponse } from "./worker";

export const protobufPackage = "broker.remote";

export interface RemoteInfoRequest {
}

export interface RemoteInfoResponse {
  workerId: string;
  activeConnections: number;
  totalConnections: Long;
  workerInfo: WorkerInfoResponse | undefined;
}

export interface RunConfigRemoteServer {
  serverUri: string;
  protocol: RunConfigRemoteServer_ServerProtocol;
}

export enum RunConfigRemoteServer_ServerProtocol {
  /** sse - Server-Sent Events */
  sse = 0,
  /** streamable_http - Streamable HTTP */
  streamable_http = 1,
  UNRECOGNIZED = -1,
}

export function runConfigRemoteServer_ServerProtocolFromJSON(object: any): RunConfigRemoteServer_ServerProtocol {
  switch (object) {
    case 0:
    case "sse":
      return RunConfigRemoteServer_ServerProtocol.sse;
    case 1:
    case "streamable_http":
      return RunConfigRemoteServer_ServerProtocol.streamable_http;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RunConfigRemoteServer_ServerProtocol.UNRECOGNIZED;
  }
}

export function runConfigRemoteServer_ServerProtocolToJSON(object: RunConfigRemoteServer_ServerProtocol): string {
  switch (object) {
    case RunConfigRemoteServer_ServerProtocol.sse:
      return "sse";
    case RunConfigRemoteServer_ServerProtocol.streamable_http:
      return "streamable_http";
    case RunConfigRemoteServer_ServerProtocol.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface RunConfigRemoteArguments {
  headers: { [key: string]: string };
  query: { [key: string]: string };
}

export interface RunConfigRemoteArguments_HeadersEntry {
  key: string;
  value: string;
}

export interface RunConfigRemoteArguments_QueryEntry {
  key: string;
  value: string;
}

export interface RunConfigRemote {
  server: RunConfigRemoteServer | undefined;
  arguments: RunConfigRemoteArguments | undefined;
}

export interface RunConfigLambdaServer {
  protocol: RunConfigLambdaServer_Protocol;
  providerResourceAccessIdentifier?: string | undefined;
  securityToken?: string | undefined;
}

export enum RunConfigLambdaServer_Protocol {
  metorial_stellar_over_websocket_v1 = 0,
  UNRECOGNIZED = -1,
}

export function runConfigLambdaServer_ProtocolFromJSON(object: any): RunConfigLambdaServer_Protocol {
  switch (object) {
    case 0:
    case "metorial_stellar_over_websocket_v1":
      return RunConfigLambdaServer_Protocol.metorial_stellar_over_websocket_v1;
    case -1:
    case "UNRECOGNIZED":
    default:
      return RunConfigLambdaServer_Protocol.UNRECOGNIZED;
  }
}

export function runConfigLambdaServer_ProtocolToJSON(object: RunConfigLambdaServer_Protocol): string {
  switch (object) {
    case RunConfigLambdaServer_Protocol.metorial_stellar_over_websocket_v1:
      return "metorial_stellar_over_websocket_v1";
    case RunConfigLambdaServer_Protocol.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface RunConfigLambdaArguments {
  jsonArguments: string;
}

export interface RunConfigLambda {
  server: RunConfigLambdaServer | undefined;
  arguments: RunConfigLambdaArguments | undefined;
}

export interface RunConfig {
  remoteRunConfig?: RunConfigRemote | undefined;
  lambdaRunConfig?: RunConfigLambda | undefined;
}

export interface RunRequest {
  init?: RunRequestInit | undefined;
  mcpMessage?: RunRequestMcpMessage | undefined;
  close?: RunRequestClose | undefined;
}

export interface RunRequestInit {
  connectionId: string;
  runConfig: RunConfig | undefined;
}

export interface RunRequestMcpMessage {
  message: McpMessageRaw | undefined;
}

export interface RunRequestClose {
}

export interface RunResponse {
  mcpMessage?: RunResponseMcpMessage | undefined;
  init?: RunResponseInit | undefined;
  output?: RunResponseOutput | undefined;
  error?: RunResponseError | undefined;
  close?: RunResponseClose | undefined;
}

export interface RunResponseInit {
}

export interface RunResponseMcpMessage {
  message: McpMessage | undefined;
}

export interface RunResponseError {
  mcpError: McpError | undefined;
}

export interface RunResponseOutput {
  mcpOutput: McpOutput | undefined;
}

export interface RunResponseClose {
}

function createBaseRemoteInfoRequest(): RemoteInfoRequest {
  return {};
}

export const RemoteInfoRequest: MessageFns<RemoteInfoRequest> = {
  encode(_: RemoteInfoRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoteInfoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoteInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RemoteInfoRequest {
    return {};
  },

  toJSON(_: RemoteInfoRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<RemoteInfoRequest>): RemoteInfoRequest {
    return RemoteInfoRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<RemoteInfoRequest>): RemoteInfoRequest {
    const message = createBaseRemoteInfoRequest();
    return message;
  },
};

function createBaseRemoteInfoResponse(): RemoteInfoResponse {
  return { workerId: "", activeConnections: 0, totalConnections: Long.UZERO, workerInfo: undefined };
}

export const RemoteInfoResponse: MessageFns<RemoteInfoResponse> = {
  encode(message: RemoteInfoResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.workerId !== "") {
      writer.uint32(10).string(message.workerId);
    }
    if (message.activeConnections !== 0) {
      writer.uint32(16).uint32(message.activeConnections);
    }
    if (!message.totalConnections.equals(Long.UZERO)) {
      writer.uint32(24).uint64(message.totalConnections.toString());
    }
    if (message.workerInfo !== undefined) {
      WorkerInfoResponse.encode(message.workerInfo, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoteInfoResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoteInfoResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.workerId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.activeConnections = reader.uint32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.totalConnections = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.workerInfo = WorkerInfoResponse.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoteInfoResponse {
    return {
      workerId: isSet(object.workerId) ? globalThis.String(object.workerId) : "",
      activeConnections: isSet(object.activeConnections) ? globalThis.Number(object.activeConnections) : 0,
      totalConnections: isSet(object.totalConnections) ? Long.fromValue(object.totalConnections) : Long.UZERO,
      workerInfo: isSet(object.workerInfo) ? WorkerInfoResponse.fromJSON(object.workerInfo) : undefined,
    };
  },

  toJSON(message: RemoteInfoResponse): unknown {
    const obj: any = {};
    if (message.workerId !== "") {
      obj.workerId = message.workerId;
    }
    if (message.activeConnections !== 0) {
      obj.activeConnections = Math.round(message.activeConnections);
    }
    if (!message.totalConnections.equals(Long.UZERO)) {
      obj.totalConnections = (message.totalConnections || Long.UZERO).toString();
    }
    if (message.workerInfo !== undefined) {
      obj.workerInfo = WorkerInfoResponse.toJSON(message.workerInfo);
    }
    return obj;
  },

  create(base?: DeepPartial<RemoteInfoResponse>): RemoteInfoResponse {
    return RemoteInfoResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RemoteInfoResponse>): RemoteInfoResponse {
    const message = createBaseRemoteInfoResponse();
    message.workerId = object.workerId ?? "";
    message.activeConnections = object.activeConnections ?? 0;
    message.totalConnections = (object.totalConnections !== undefined && object.totalConnections !== null)
      ? Long.fromValue(object.totalConnections)
      : Long.UZERO;
    message.workerInfo = (object.workerInfo !== undefined && object.workerInfo !== null)
      ? WorkerInfoResponse.fromPartial(object.workerInfo)
      : undefined;
    return message;
  },
};

function createBaseRunConfigRemoteServer(): RunConfigRemoteServer {
  return { serverUri: "", protocol: 0 };
}

export const RunConfigRemoteServer: MessageFns<RunConfigRemoteServer> = {
  encode(message: RunConfigRemoteServer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.serverUri !== "") {
      writer.uint32(10).string(message.serverUri);
    }
    if (message.protocol !== 0) {
      writer.uint32(16).int32(message.protocol);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunConfigRemoteServer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunConfigRemoteServer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.serverUri = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.protocol = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunConfigRemoteServer {
    return {
      serverUri: isSet(object.serverUri) ? globalThis.String(object.serverUri) : "",
      protocol: isSet(object.protocol) ? runConfigRemoteServer_ServerProtocolFromJSON(object.protocol) : 0,
    };
  },

  toJSON(message: RunConfigRemoteServer): unknown {
    const obj: any = {};
    if (message.serverUri !== "") {
      obj.serverUri = message.serverUri;
    }
    if (message.protocol !== 0) {
      obj.protocol = runConfigRemoteServer_ServerProtocolToJSON(message.protocol);
    }
    return obj;
  },

  create(base?: DeepPartial<RunConfigRemoteServer>): RunConfigRemoteServer {
    return RunConfigRemoteServer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RunConfigRemoteServer>): RunConfigRemoteServer {
    const message = createBaseRunConfigRemoteServer();
    message.serverUri = object.serverUri ?? "";
    message.protocol = object.protocol ?? 0;
    return message;
  },
};

function createBaseRunConfigRemoteArguments(): RunConfigRemoteArguments {
  return { headers: {}, query: {} };
}

export const RunConfigRemoteArguments: MessageFns<RunConfigRemoteArguments> = {
  encode(message: RunConfigRemoteArguments, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.headers).forEach(([key, value]) => {
      RunConfigRemoteArguments_HeadersEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    Object.entries(message.query).forEach(([key, value]) => {
      RunConfigRemoteArguments_QueryEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunConfigRemoteArguments {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunConfigRemoteArguments();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          const entry1 = RunConfigRemoteArguments_HeadersEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.headers[entry1.key] = entry1.value;
          }
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = RunConfigRemoteArguments_QueryEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.query[entry2.key] = entry2.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunConfigRemoteArguments {
    return {
      headers: isObject(object.headers)
        ? Object.entries(object.headers).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      query: isObject(object.query)
        ? Object.entries(object.query).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: RunConfigRemoteArguments): unknown {
    const obj: any = {};
    if (message.headers) {
      const entries = Object.entries(message.headers);
      if (entries.length > 0) {
        obj.headers = {};
        entries.forEach(([k, v]) => {
          obj.headers[k] = v;
        });
      }
    }
    if (message.query) {
      const entries = Object.entries(message.query);
      if (entries.length > 0) {
        obj.query = {};
        entries.forEach(([k, v]) => {
          obj.query[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<RunConfigRemoteArguments>): RunConfigRemoteArguments {
    return RunConfigRemoteArguments.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RunConfigRemoteArguments>): RunConfigRemoteArguments {
    const message = createBaseRunConfigRemoteArguments();
    message.headers = Object.entries(object.headers ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.query = Object.entries(object.query ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseRunConfigRemoteArguments_HeadersEntry(): RunConfigRemoteArguments_HeadersEntry {
  return { key: "", value: "" };
}

export const RunConfigRemoteArguments_HeadersEntry: MessageFns<RunConfigRemoteArguments_HeadersEntry> = {
  encode(message: RunConfigRemoteArguments_HeadersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunConfigRemoteArguments_HeadersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunConfigRemoteArguments_HeadersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunConfigRemoteArguments_HeadersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: RunConfigRemoteArguments_HeadersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<RunConfigRemoteArguments_HeadersEntry>): RunConfigRemoteArguments_HeadersEntry {
    return RunConfigRemoteArguments_HeadersEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RunConfigRemoteArguments_HeadersEntry>): RunConfigRemoteArguments_HeadersEntry {
    const message = createBaseRunConfigRemoteArguments_HeadersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseRunConfigRemoteArguments_QueryEntry(): RunConfigRemoteArguments_QueryEntry {
  return { key: "", value: "" };
}

export const RunConfigRemoteArguments_QueryEntry: MessageFns<RunConfigRemoteArguments_QueryEntry> = {
  encode(message: RunConfigRemoteArguments_QueryEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunConfigRemoteArguments_QueryEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunConfigRemoteArguments_QueryEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunConfigRemoteArguments_QueryEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: RunConfigRemoteArguments_QueryEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<RunConfigRemoteArguments_QueryEntry>): RunConfigRemoteArguments_QueryEntry {
    return RunConfigRemoteArguments_QueryEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RunConfigRemoteArguments_QueryEntry>): RunConfigRemoteArguments_QueryEntry {
    const message = createBaseRunConfigRemoteArguments_QueryEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseRunConfigRemote(): RunConfigRemote {
  return { server: undefined, arguments: undefined };
}

export const RunConfigRemote: MessageFns<RunConfigRemote> = {
  encode(message: RunConfigRemote, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.server !== undefined) {
      RunConfigRemoteServer.encode(message.server, writer.uint32(10).fork()).join();
    }
    if (message.arguments !== undefined) {
      RunConfigRemoteArguments.encode(message.arguments, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunConfigRemote {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunConfigRemote();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.server = RunConfigRemoteServer.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.arguments = RunConfigRemoteArguments.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunConfigRemote {
    return {
      server: isSet(object.server) ? RunConfigRemoteServer.fromJSON(object.server) : undefined,
      arguments: isSet(object.arguments) ? RunConfigRemoteArguments.fromJSON(object.arguments) : undefined,
    };
  },

  toJSON(message: RunConfigRemote): unknown {
    const obj: any = {};
    if (message.server !== undefined) {
      obj.server = RunConfigRemoteServer.toJSON(message.server);
    }
    if (message.arguments !== undefined) {
      obj.arguments = RunConfigRemoteArguments.toJSON(message.arguments);
    }
    return obj;
  },

  create(base?: DeepPartial<RunConfigRemote>): RunConfigRemote {
    return RunConfigRemote.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RunConfigRemote>): RunConfigRemote {
    const message = createBaseRunConfigRemote();
    message.server = (object.server !== undefined && object.server !== null)
      ? RunConfigRemoteServer.fromPartial(object.server)
      : undefined;
    message.arguments = (object.arguments !== undefined && object.arguments !== null)
      ? RunConfigRemoteArguments.fromPartial(object.arguments)
      : undefined;
    return message;
  },
};

function createBaseRunConfigLambdaServer(): RunConfigLambdaServer {
  return { protocol: 0, providerResourceAccessIdentifier: undefined, securityToken: undefined };
}

export const RunConfigLambdaServer: MessageFns<RunConfigLambdaServer> = {
  encode(message: RunConfigLambdaServer, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.protocol !== 0) {
      writer.uint32(8).int32(message.protocol);
    }
    if (message.providerResourceAccessIdentifier !== undefined) {
      writer.uint32(18).string(message.providerResourceAccessIdentifier);
    }
    if (message.securityToken !== undefined) {
      writer.uint32(26).string(message.securityToken);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunConfigLambdaServer {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunConfigLambdaServer();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.protocol = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.providerResourceAccessIdentifier = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.securityToken = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunConfigLambdaServer {
    return {
      protocol: isSet(object.protocol) ? runConfigLambdaServer_ProtocolFromJSON(object.protocol) : 0,
      providerResourceAccessIdentifier: isSet(object.providerResourceAccessIdentifier)
        ? globalThis.String(object.providerResourceAccessIdentifier)
        : undefined,
      securityToken: isSet(object.securityToken) ? globalThis.String(object.securityToken) : undefined,
    };
  },

  toJSON(message: RunConfigLambdaServer): unknown {
    const obj: any = {};
    if (message.protocol !== 0) {
      obj.protocol = runConfigLambdaServer_ProtocolToJSON(message.protocol);
    }
    if (message.providerResourceAccessIdentifier !== undefined) {
      obj.providerResourceAccessIdentifier = message.providerResourceAccessIdentifier;
    }
    if (message.securityToken !== undefined) {
      obj.securityToken = message.securityToken;
    }
    return obj;
  },

  create(base?: DeepPartial<RunConfigLambdaServer>): RunConfigLambdaServer {
    return RunConfigLambdaServer.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RunConfigLambdaServer>): RunConfigLambdaServer {
    const message = createBaseRunConfigLambdaServer();
    message.protocol = object.protocol ?? 0;
    message.providerResourceAccessIdentifier = object.providerResourceAccessIdentifier ?? undefined;
    message.securityToken = object.securityToken ?? undefined;
    return message;
  },
};

function createBaseRunConfigLambdaArguments(): RunConfigLambdaArguments {
  return { jsonArguments: "" };
}

export const RunConfigLambdaArguments: MessageFns<RunConfigLambdaArguments> = {
  encode(message: RunConfigLambdaArguments, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.jsonArguments !== "") {
      writer.uint32(10).string(message.jsonArguments);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunConfigLambdaArguments {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunConfigLambdaArguments();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.jsonArguments = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunConfigLambdaArguments {
    return { jsonArguments: isSet(object.jsonArguments) ? globalThis.String(object.jsonArguments) : "" };
  },

  toJSON(message: RunConfigLambdaArguments): unknown {
    const obj: any = {};
    if (message.jsonArguments !== "") {
      obj.jsonArguments = message.jsonArguments;
    }
    return obj;
  },

  create(base?: DeepPartial<RunConfigLambdaArguments>): RunConfigLambdaArguments {
    return RunConfigLambdaArguments.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RunConfigLambdaArguments>): RunConfigLambdaArguments {
    const message = createBaseRunConfigLambdaArguments();
    message.jsonArguments = object.jsonArguments ?? "";
    return message;
  },
};

function createBaseRunConfigLambda(): RunConfigLambda {
  return { server: undefined, arguments: undefined };
}

export const RunConfigLambda: MessageFns<RunConfigLambda> = {
  encode(message: RunConfigLambda, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.server !== undefined) {
      RunConfigLambdaServer.encode(message.server, writer.uint32(10).fork()).join();
    }
    if (message.arguments !== undefined) {
      RunConfigLambdaArguments.encode(message.arguments, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunConfigLambda {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunConfigLambda();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.server = RunConfigLambdaServer.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.arguments = RunConfigLambdaArguments.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunConfigLambda {
    return {
      server: isSet(object.server) ? RunConfigLambdaServer.fromJSON(object.server) : undefined,
      arguments: isSet(object.arguments) ? RunConfigLambdaArguments.fromJSON(object.arguments) : undefined,
    };
  },

  toJSON(message: RunConfigLambda): unknown {
    const obj: any = {};
    if (message.server !== undefined) {
      obj.server = RunConfigLambdaServer.toJSON(message.server);
    }
    if (message.arguments !== undefined) {
      obj.arguments = RunConfigLambdaArguments.toJSON(message.arguments);
    }
    return obj;
  },

  create(base?: DeepPartial<RunConfigLambda>): RunConfigLambda {
    return RunConfigLambda.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RunConfigLambda>): RunConfigLambda {
    const message = createBaseRunConfigLambda();
    message.server = (object.server !== undefined && object.server !== null)
      ? RunConfigLambdaServer.fromPartial(object.server)
      : undefined;
    message.arguments = (object.arguments !== undefined && object.arguments !== null)
      ? RunConfigLambdaArguments.fromPartial(object.arguments)
      : undefined;
    return message;
  },
};

function createBaseRunConfig(): RunConfig {
  return { remoteRunConfig: undefined, lambdaRunConfig: undefined };
}

export const RunConfig: MessageFns<RunConfig> = {
  encode(message: RunConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.remoteRunConfig !== undefined) {
      RunConfigRemote.encode(message.remoteRunConfig, writer.uint32(10).fork()).join();
    }
    if (message.lambdaRunConfig !== undefined) {
      RunConfigLambda.encode(message.lambdaRunConfig, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.remoteRunConfig = RunConfigRemote.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.lambdaRunConfig = RunConfigLambda.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunConfig {
    return {
      remoteRunConfig: isSet(object.remoteRunConfig) ? RunConfigRemote.fromJSON(object.remoteRunConfig) : undefined,
      lambdaRunConfig: isSet(object.lambdaRunConfig) ? RunConfigLambda.fromJSON(object.lambdaRunConfig) : undefined,
    };
  },

  toJSON(message: RunConfig): unknown {
    const obj: any = {};
    if (message.remoteRunConfig !== undefined) {
      obj.remoteRunConfig = RunConfigRemote.toJSON(message.remoteRunConfig);
    }
    if (message.lambdaRunConfig !== undefined) {
      obj.lambdaRunConfig = RunConfigLambda.toJSON(message.lambdaRunConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<RunConfig>): RunConfig {
    return RunConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RunConfig>): RunConfig {
    const message = createBaseRunConfig();
    message.remoteRunConfig = (object.remoteRunConfig !== undefined && object.remoteRunConfig !== null)
      ? RunConfigRemote.fromPartial(object.remoteRunConfig)
      : undefined;
    message.lambdaRunConfig = (object.lambdaRunConfig !== undefined && object.lambdaRunConfig !== null)
      ? RunConfigLambda.fromPartial(object.lambdaRunConfig)
      : undefined;
    return message;
  },
};

function createBaseRunRequest(): RunRequest {
  return { init: undefined, mcpMessage: undefined, close: undefined };
}

export const RunRequest: MessageFns<RunRequest> = {
  encode(message: RunRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.init !== undefined) {
      RunRequestInit.encode(message.init, writer.uint32(10).fork()).join();
    }
    if (message.mcpMessage !== undefined) {
      RunRequestMcpMessage.encode(message.mcpMessage, writer.uint32(18).fork()).join();
    }
    if (message.close !== undefined) {
      RunRequestClose.encode(message.close, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.init = RunRequestInit.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.mcpMessage = RunRequestMcpMessage.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.close = RunRequestClose.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunRequest {
    return {
      init: isSet(object.init) ? RunRequestInit.fromJSON(object.init) : undefined,
      mcpMessage: isSet(object.mcpMessage) ? RunRequestMcpMessage.fromJSON(object.mcpMessage) : undefined,
      close: isSet(object.close) ? RunRequestClose.fromJSON(object.close) : undefined,
    };
  },

  toJSON(message: RunRequest): unknown {
    const obj: any = {};
    if (message.init !== undefined) {
      obj.init = RunRequestInit.toJSON(message.init);
    }
    if (message.mcpMessage !== undefined) {
      obj.mcpMessage = RunRequestMcpMessage.toJSON(message.mcpMessage);
    }
    if (message.close !== undefined) {
      obj.close = RunRequestClose.toJSON(message.close);
    }
    return obj;
  },

  create(base?: DeepPartial<RunRequest>): RunRequest {
    return RunRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RunRequest>): RunRequest {
    const message = createBaseRunRequest();
    message.init = (object.init !== undefined && object.init !== null)
      ? RunRequestInit.fromPartial(object.init)
      : undefined;
    message.mcpMessage = (object.mcpMessage !== undefined && object.mcpMessage !== null)
      ? RunRequestMcpMessage.fromPartial(object.mcpMessage)
      : undefined;
    message.close = (object.close !== undefined && object.close !== null)
      ? RunRequestClose.fromPartial(object.close)
      : undefined;
    return message;
  },
};

function createBaseRunRequestInit(): RunRequestInit {
  return { connectionId: "", runConfig: undefined };
}

export const RunRequestInit: MessageFns<RunRequestInit> = {
  encode(message: RunRequestInit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.connectionId !== "") {
      writer.uint32(10).string(message.connectionId);
    }
    if (message.runConfig !== undefined) {
      RunConfig.encode(message.runConfig, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunRequestInit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunRequestInit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.connectionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.runConfig = RunConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunRequestInit {
    return {
      connectionId: isSet(object.connectionId) ? globalThis.String(object.connectionId) : "",
      runConfig: isSet(object.runConfig) ? RunConfig.fromJSON(object.runConfig) : undefined,
    };
  },

  toJSON(message: RunRequestInit): unknown {
    const obj: any = {};
    if (message.connectionId !== "") {
      obj.connectionId = message.connectionId;
    }
    if (message.runConfig !== undefined) {
      obj.runConfig = RunConfig.toJSON(message.runConfig);
    }
    return obj;
  },

  create(base?: DeepPartial<RunRequestInit>): RunRequestInit {
    return RunRequestInit.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RunRequestInit>): RunRequestInit {
    const message = createBaseRunRequestInit();
    message.connectionId = object.connectionId ?? "";
    message.runConfig = (object.runConfig !== undefined && object.runConfig !== null)
      ? RunConfig.fromPartial(object.runConfig)
      : undefined;
    return message;
  },
};

function createBaseRunRequestMcpMessage(): RunRequestMcpMessage {
  return { message: undefined };
}

export const RunRequestMcpMessage: MessageFns<RunRequestMcpMessage> = {
  encode(message: RunRequestMcpMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== undefined) {
      McpMessageRaw.encode(message.message, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunRequestMcpMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunRequestMcpMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = McpMessageRaw.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunRequestMcpMessage {
    return { message: isSet(object.message) ? McpMessageRaw.fromJSON(object.message) : undefined };
  },

  toJSON(message: RunRequestMcpMessage): unknown {
    const obj: any = {};
    if (message.message !== undefined) {
      obj.message = McpMessageRaw.toJSON(message.message);
    }
    return obj;
  },

  create(base?: DeepPartial<RunRequestMcpMessage>): RunRequestMcpMessage {
    return RunRequestMcpMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RunRequestMcpMessage>): RunRequestMcpMessage {
    const message = createBaseRunRequestMcpMessage();
    message.message = (object.message !== undefined && object.message !== null)
      ? McpMessageRaw.fromPartial(object.message)
      : undefined;
    return message;
  },
};

function createBaseRunRequestClose(): RunRequestClose {
  return {};
}

export const RunRequestClose: MessageFns<RunRequestClose> = {
  encode(_: RunRequestClose, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunRequestClose {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunRequestClose();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RunRequestClose {
    return {};
  },

  toJSON(_: RunRequestClose): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<RunRequestClose>): RunRequestClose {
    return RunRequestClose.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<RunRequestClose>): RunRequestClose {
    const message = createBaseRunRequestClose();
    return message;
  },
};

function createBaseRunResponse(): RunResponse {
  return { mcpMessage: undefined, init: undefined, output: undefined, error: undefined, close: undefined };
}

export const RunResponse: MessageFns<RunResponse> = {
  encode(message: RunResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mcpMessage !== undefined) {
      RunResponseMcpMessage.encode(message.mcpMessage, writer.uint32(10).fork()).join();
    }
    if (message.init !== undefined) {
      RunResponseInit.encode(message.init, writer.uint32(18).fork()).join();
    }
    if (message.output !== undefined) {
      RunResponseOutput.encode(message.output, writer.uint32(26).fork()).join();
    }
    if (message.error !== undefined) {
      RunResponseError.encode(message.error, writer.uint32(34).fork()).join();
    }
    if (message.close !== undefined) {
      RunResponseClose.encode(message.close, writer.uint32(42).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mcpMessage = RunResponseMcpMessage.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.init = RunResponseInit.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.output = RunResponseOutput.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.error = RunResponseError.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.close = RunResponseClose.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunResponse {
    return {
      mcpMessage: isSet(object.mcpMessage) ? RunResponseMcpMessage.fromJSON(object.mcpMessage) : undefined,
      init: isSet(object.init) ? RunResponseInit.fromJSON(object.init) : undefined,
      output: isSet(object.output) ? RunResponseOutput.fromJSON(object.output) : undefined,
      error: isSet(object.error) ? RunResponseError.fromJSON(object.error) : undefined,
      close: isSet(object.close) ? RunResponseClose.fromJSON(object.close) : undefined,
    };
  },

  toJSON(message: RunResponse): unknown {
    const obj: any = {};
    if (message.mcpMessage !== undefined) {
      obj.mcpMessage = RunResponseMcpMessage.toJSON(message.mcpMessage);
    }
    if (message.init !== undefined) {
      obj.init = RunResponseInit.toJSON(message.init);
    }
    if (message.output !== undefined) {
      obj.output = RunResponseOutput.toJSON(message.output);
    }
    if (message.error !== undefined) {
      obj.error = RunResponseError.toJSON(message.error);
    }
    if (message.close !== undefined) {
      obj.close = RunResponseClose.toJSON(message.close);
    }
    return obj;
  },

  create(base?: DeepPartial<RunResponse>): RunResponse {
    return RunResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RunResponse>): RunResponse {
    const message = createBaseRunResponse();
    message.mcpMessage = (object.mcpMessage !== undefined && object.mcpMessage !== null)
      ? RunResponseMcpMessage.fromPartial(object.mcpMessage)
      : undefined;
    message.init = (object.init !== undefined && object.init !== null)
      ? RunResponseInit.fromPartial(object.init)
      : undefined;
    message.output = (object.output !== undefined && object.output !== null)
      ? RunResponseOutput.fromPartial(object.output)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null)
      ? RunResponseError.fromPartial(object.error)
      : undefined;
    message.close = (object.close !== undefined && object.close !== null)
      ? RunResponseClose.fromPartial(object.close)
      : undefined;
    return message;
  },
};

function createBaseRunResponseInit(): RunResponseInit {
  return {};
}

export const RunResponseInit: MessageFns<RunResponseInit> = {
  encode(_: RunResponseInit, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunResponseInit {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunResponseInit();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RunResponseInit {
    return {};
  },

  toJSON(_: RunResponseInit): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<RunResponseInit>): RunResponseInit {
    return RunResponseInit.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<RunResponseInit>): RunResponseInit {
    const message = createBaseRunResponseInit();
    return message;
  },
};

function createBaseRunResponseMcpMessage(): RunResponseMcpMessage {
  return { message: undefined };
}

export const RunResponseMcpMessage: MessageFns<RunResponseMcpMessage> = {
  encode(message: RunResponseMcpMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== undefined) {
      McpMessage.encode(message.message, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunResponseMcpMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunResponseMcpMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = McpMessage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunResponseMcpMessage {
    return { message: isSet(object.message) ? McpMessage.fromJSON(object.message) : undefined };
  },

  toJSON(message: RunResponseMcpMessage): unknown {
    const obj: any = {};
    if (message.message !== undefined) {
      obj.message = McpMessage.toJSON(message.message);
    }
    return obj;
  },

  create(base?: DeepPartial<RunResponseMcpMessage>): RunResponseMcpMessage {
    return RunResponseMcpMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RunResponseMcpMessage>): RunResponseMcpMessage {
    const message = createBaseRunResponseMcpMessage();
    message.message = (object.message !== undefined && object.message !== null)
      ? McpMessage.fromPartial(object.message)
      : undefined;
    return message;
  },
};

function createBaseRunResponseError(): RunResponseError {
  return { mcpError: undefined };
}

export const RunResponseError: MessageFns<RunResponseError> = {
  encode(message: RunResponseError, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mcpError !== undefined) {
      McpError.encode(message.mcpError, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunResponseError {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunResponseError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mcpError = McpError.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunResponseError {
    return { mcpError: isSet(object.mcpError) ? McpError.fromJSON(object.mcpError) : undefined };
  },

  toJSON(message: RunResponseError): unknown {
    const obj: any = {};
    if (message.mcpError !== undefined) {
      obj.mcpError = McpError.toJSON(message.mcpError);
    }
    return obj;
  },

  create(base?: DeepPartial<RunResponseError>): RunResponseError {
    return RunResponseError.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RunResponseError>): RunResponseError {
    const message = createBaseRunResponseError();
    message.mcpError = (object.mcpError !== undefined && object.mcpError !== null)
      ? McpError.fromPartial(object.mcpError)
      : undefined;
    return message;
  },
};

function createBaseRunResponseOutput(): RunResponseOutput {
  return { mcpOutput: undefined };
}

export const RunResponseOutput: MessageFns<RunResponseOutput> = {
  encode(message: RunResponseOutput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mcpOutput !== undefined) {
      McpOutput.encode(message.mcpOutput, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunResponseOutput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunResponseOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mcpOutput = McpOutput.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RunResponseOutput {
    return { mcpOutput: isSet(object.mcpOutput) ? McpOutput.fromJSON(object.mcpOutput) : undefined };
  },

  toJSON(message: RunResponseOutput): unknown {
    const obj: any = {};
    if (message.mcpOutput !== undefined) {
      obj.mcpOutput = McpOutput.toJSON(message.mcpOutput);
    }
    return obj;
  },

  create(base?: DeepPartial<RunResponseOutput>): RunResponseOutput {
    return RunResponseOutput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RunResponseOutput>): RunResponseOutput {
    const message = createBaseRunResponseOutput();
    message.mcpOutput = (object.mcpOutput !== undefined && object.mcpOutput !== null)
      ? McpOutput.fromPartial(object.mcpOutput)
      : undefined;
    return message;
  },
};

function createBaseRunResponseClose(): RunResponseClose {
  return {};
}

export const RunResponseClose: MessageFns<RunResponseClose> = {
  encode(_: RunResponseClose, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunResponseClose {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRunResponseClose();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): RunResponseClose {
    return {};
  },

  toJSON(_: RunResponseClose): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<RunResponseClose>): RunResponseClose {
    return RunResponseClose.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<RunResponseClose>): RunResponseClose {
    const message = createBaseRunResponseClose();
    return message;
  },
};

export type McpRemoteService = typeof McpRemoteService;
export const McpRemoteService = {
  /** rpc GetRemoteInfo(RemoteInfoRequest) returns (RemoteInfoResponse); */
  streamMcpRun: {
    path: "/broker.remote.McpRemote/StreamMcpRun",
    requestStream: true,
    responseStream: true,
    requestSerialize: (value: RunRequest): Buffer => Buffer.from(RunRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): RunRequest => RunRequest.decode(value),
    responseSerialize: (value: RunResponse): Buffer => Buffer.from(RunResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): RunResponse => RunResponse.decode(value),
  },
} as const;

export interface McpRemoteServer extends UntypedServiceImplementation {
  /** rpc GetRemoteInfo(RemoteInfoRequest) returns (RemoteInfoResponse); */
  streamMcpRun: handleBidiStreamingCall<RunRequest, RunResponse>;
}

export interface McpRemoteClient extends Client {
  /** rpc GetRemoteInfo(RemoteInfoRequest) returns (RemoteInfoResponse); */
  streamMcpRun(): ClientDuplexStream<RunRequest, RunResponse>;
  streamMcpRun(options: Partial<CallOptions>): ClientDuplexStream<RunRequest, RunResponse>;
  streamMcpRun(metadata: Metadata, options?: Partial<CallOptions>): ClientDuplexStream<RunRequest, RunResponse>;
}

export const McpRemoteClient = makeGenericClientConstructor(McpRemoteService, "broker.remote.McpRemote") as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): McpRemoteClient;
  service: typeof McpRemoteService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
