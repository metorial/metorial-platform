// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v6.31.1
// source: manager.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  type ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientReadableStream,
  type ClientUnaryCall,
  type handleServerStreamingCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  type Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import Long from "long";
import { Empty } from "./common";
import { LauncherConfig } from "./launcher";
import {
  McpError,
  McpMessage,
  McpMessageRaw,
  McpMessageType,
  mcpMessageTypeFromJSON,
  mcpMessageTypeToJSON,
  McpOutput,
  McpParticipant,
} from "./mcp";
import { RunConfig as RunConfig1, RunConfigRemoteServer } from "./remote";
import { RunConfig, RunConfigContainer } from "./runner";
import { ListManagersRequest, ListManagersResponse } from "./workerBroker";

export const protobufPackage = "broker.manager";

export enum EngineSessionStatus {
  session_status_active = 0,
  session_status_closed = 1,
  session_status_expired = 2,
  session_status_error = 3,
  session_status_unknown = 4,
  UNRECOGNIZED = -1,
}

export function engineSessionStatusFromJSON(object: any): EngineSessionStatus {
  switch (object) {
    case 0:
    case "session_status_active":
      return EngineSessionStatus.session_status_active;
    case 1:
    case "session_status_closed":
      return EngineSessionStatus.session_status_closed;
    case 2:
    case "session_status_expired":
      return EngineSessionStatus.session_status_expired;
    case 3:
    case "session_status_error":
      return EngineSessionStatus.session_status_error;
    case 4:
    case "session_status_unknown":
      return EngineSessionStatus.session_status_unknown;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EngineSessionStatus.UNRECOGNIZED;
  }
}

export function engineSessionStatusToJSON(object: EngineSessionStatus): string {
  switch (object) {
    case EngineSessionStatus.session_status_active:
      return "session_status_active";
    case EngineSessionStatus.session_status_closed:
      return "session_status_closed";
    case EngineSessionStatus.session_status_expired:
      return "session_status_expired";
    case EngineSessionStatus.session_status_error:
      return "session_status_error";
    case EngineSessionStatus.session_status_unknown:
      return "session_status_unknown";
    case EngineSessionStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum EngineSessionType {
  session_type_unknown = 0,
  session_type_container = 1,
  session_type_remote = 2,
  UNRECOGNIZED = -1,
}

export function engineSessionTypeFromJSON(object: any): EngineSessionType {
  switch (object) {
    case 0:
    case "session_type_unknown":
      return EngineSessionType.session_type_unknown;
    case 1:
    case "session_type_container":
      return EngineSessionType.session_type_container;
    case 2:
    case "session_type_remote":
      return EngineSessionType.session_type_remote;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EngineSessionType.UNRECOGNIZED;
  }
}

export function engineSessionTypeToJSON(object: EngineSessionType): string {
  switch (object) {
    case EngineSessionType.session_type_unknown:
      return "session_type_unknown";
    case EngineSessionType.session_type_container:
      return "session_type_container";
    case EngineSessionType.session_type_remote:
      return "session_type_remote";
    case EngineSessionType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum EngineRunStatus {
  run_status_active = 0,
  run_status_closed = 1,
  run_status_expired = 2,
  run_status_error = 3,
  run_status_unknown = 4,
  UNRECOGNIZED = -1,
}

export function engineRunStatusFromJSON(object: any): EngineRunStatus {
  switch (object) {
    case 0:
    case "run_status_active":
      return EngineRunStatus.run_status_active;
    case 1:
    case "run_status_closed":
      return EngineRunStatus.run_status_closed;
    case 2:
    case "run_status_expired":
      return EngineRunStatus.run_status_expired;
    case 3:
    case "run_status_error":
      return EngineRunStatus.run_status_error;
    case 4:
    case "run_status_unknown":
      return EngineRunStatus.run_status_unknown;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EngineRunStatus.UNRECOGNIZED;
  }
}

export function engineRunStatusToJSON(object: EngineRunStatus): string {
  switch (object) {
    case EngineRunStatus.run_status_active:
      return "run_status_active";
    case EngineRunStatus.run_status_closed:
      return "run_status_closed";
    case EngineRunStatus.run_status_expired:
      return "run_status_expired";
    case EngineRunStatus.run_status_error:
      return "run_status_error";
    case EngineRunStatus.run_status_unknown:
      return "run_status_unknown";
    case EngineRunStatus.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum EngineRunType {
  run_type_unknown = 0,
  run_type_container = 1,
  run_type_remote = 2,
  UNRECOGNIZED = -1,
}

export function engineRunTypeFromJSON(object: any): EngineRunType {
  switch (object) {
    case 0:
    case "run_type_unknown":
      return EngineRunType.run_type_unknown;
    case 1:
    case "run_type_container":
      return EngineRunType.run_type_container;
    case 2:
    case "run_type_remote":
      return EngineRunType.run_type_remote;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EngineRunType.UNRECOGNIZED;
  }
}

export function engineRunTypeToJSON(object: EngineRunType): string {
  switch (object) {
    case EngineRunType.run_type_unknown:
      return "run_type_unknown";
    case EngineRunType.run_type_container:
      return "run_type_container";
    case EngineRunType.run_type_remote:
      return "run_type_remote";
    case EngineRunType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum EngineSessionEventType {
  session_event_type_output = 0,
  session_event_type_error = 1,
  session_event_type_log = 2,
  session_event_type_unknown = 3,
  UNRECOGNIZED = -1,
}

export function engineSessionEventTypeFromJSON(object: any): EngineSessionEventType {
  switch (object) {
    case 0:
    case "session_event_type_output":
      return EngineSessionEventType.session_event_type_output;
    case 1:
    case "session_event_type_error":
      return EngineSessionEventType.session_event_type_error;
    case 2:
    case "session_event_type_log":
      return EngineSessionEventType.session_event_type_log;
    case 3:
    case "session_event_type_unknown":
      return EngineSessionEventType.session_event_type_unknown;
    case -1:
    case "UNRECOGNIZED":
    default:
      return EngineSessionEventType.UNRECOGNIZED;
  }
}

export function engineSessionEventTypeToJSON(object: EngineSessionEventType): string {
  switch (object) {
    case EngineSessionEventType.session_event_type_output:
      return "session_event_type_output";
    case EngineSessionEventType.session_event_type_error:
      return "session_event_type_error";
    case EngineSessionEventType.session_event_type_log:
      return "session_event_type_log";
    case EngineSessionEventType.session_event_type_unknown:
      return "session_event_type_unknown";
    case EngineSessionEventType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum SessionMessageSender {
  session_message_sender_unknown = 0,
  session_message_sender_client = 1,
  session_message_sender_server = 2,
  UNRECOGNIZED = -1,
}

export function sessionMessageSenderFromJSON(object: any): SessionMessageSender {
  switch (object) {
    case 0:
    case "session_message_sender_unknown":
      return SessionMessageSender.session_message_sender_unknown;
    case 1:
    case "session_message_sender_client":
      return SessionMessageSender.session_message_sender_client;
    case 2:
    case "session_message_sender_server":
      return SessionMessageSender.session_message_sender_server;
    case -1:
    case "UNRECOGNIZED":
    default:
      return SessionMessageSender.UNRECOGNIZED;
  }
}

export function sessionMessageSenderToJSON(object: SessionMessageSender): string {
  switch (object) {
    case SessionMessageSender.session_message_sender_unknown:
      return "session_message_sender_unknown";
    case SessionMessageSender.session_message_sender_client:
      return "session_message_sender_client";
    case SessionMessageSender.session_message_sender_server:
      return "session_message_sender_server";
    case SessionMessageSender.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ListPaginationOrder {
  list_cursor_order_asc = 0,
  list_cursor_order_desc = 1,
  UNRECOGNIZED = -1,
}

export function listPaginationOrderFromJSON(object: any): ListPaginationOrder {
  switch (object) {
    case 0:
    case "list_cursor_order_asc":
      return ListPaginationOrder.list_cursor_order_asc;
    case 1:
    case "list_cursor_order_desc":
      return ListPaginationOrder.list_cursor_order_desc;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ListPaginationOrder.UNRECOGNIZED;
  }
}

export function listPaginationOrderToJSON(object: ListPaginationOrder): string {
  switch (object) {
    case ListPaginationOrder.list_cursor_order_asc:
      return "list_cursor_order_asc";
    case ListPaginationOrder.list_cursor_order_desc:
      return "list_cursor_order_desc";
    case ListPaginationOrder.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface CreateSessionRequest {
  sessionId: string;
  config: SessionConfig | undefined;
  mcpClient:
    | McpParticipant
    | undefined;
  /** Optional, Additional metadata for the session */
  metadata: { [key: string]: string };
}

export interface CreateSessionRequest_MetadataEntry {
  key: string;
  value: string;
}

export interface ContainerRunConfigWithLauncher {
  container: RunConfigContainer | undefined;
  launcher: LauncherConfig | undefined;
}

export interface RemoteRunConfigWithLauncher {
  server: RunConfigRemoteServer | undefined;
  launcher: LauncherConfig | undefined;
}

export interface SessionConfig {
  containerRunConfigWithLauncher?: ContainerRunConfigWithLauncher | undefined;
  containerRunConfigWithContainerArguments?: RunConfig | undefined;
  remoteRunConfigWithLauncher?: RemoteRunConfigWithLauncher | undefined;
  remoteRunConfigWithServer?: RunConfig1 | undefined;
}

export interface CreateSessionResponse {
  sessionId: string;
  session: EngineSession | undefined;
}

export interface SendMcpMessageRequest {
  sessionId: string;
  mcpMessages: McpMessageRaw[];
  includeResponses: boolean;
}

export interface SendMcpMessageResponse {
  mcpMessage?: McpMessage | undefined;
  mcpError?: McpError | undefined;
  sessionEvent?: SessionEvent | undefined;
}

export interface StreamMcpMessagesRequest {
  sessionId: string;
  /** Optional, if empty, all message types are streamed */
  onlyMessageTypes: McpMessageType[];
  /** Optional, if empty, all messages are streamed */
  onlyIds: string[];
  /** Include messages after this UUID, useful for resuming streams */
  replayAfterUuid: string;
}

export interface SessionEventInfoRun {
  run: EngineSessionRun | undefined;
}

export interface SessionEventInfoSession {
  session: EngineSession | undefined;
}

export interface SessionEventStartRun {
  run: EngineSessionRun | undefined;
}

export interface SessionEventStopRun {
  run: EngineSessionRun | undefined;
}

export interface SessionEvent {
  startRun?: SessionEventStartRun | undefined;
  stopRun?: SessionEventStopRun | undefined;
  infoRun?: SessionEventInfoRun | undefined;
  infoSession?: SessionEventInfoSession | undefined;
}

export interface StreamMcpMessagesResponse {
  mcpMessage?: McpMessage | undefined;
  mcpError?: McpError | undefined;
  mcpOutput?: McpOutput | undefined;
  sessionEvent?: SessionEvent | undefined;
  isReplay: boolean;
}

export interface GetServerInfoRequest {
  sessionId: string;
}

export interface ListWorkersRequest {
}

export interface ListWorkersResponse {
  workers: WorkerInfo[];
}

export interface WorkerInfo {
  workerId: string;
  address: string;
  acceptingRuns: boolean;
  healthy: boolean;
}

export interface DiscardSessionRequest {
  sessionId: string;
}

export interface DiscardSessionResponse {
}

export interface EngineSession {
  id: string;
  externalId: string;
  type: EngineSessionType;
  status: EngineSessionStatus;
  hasError: boolean;
  mcpClient: McpParticipant | undefined;
  mcpServer: McpParticipant | undefined;
  createdAt: Long;
  updatedAt: Long;
  startedAt: Long;
  endedAt: Long;
  lastPingAt: Long;
}

export interface EngineSessionRun {
  id: string;
  sessionId: string;
  type: EngineRunType;
  status: EngineRunStatus;
  hasError: boolean;
  workerId: string;
  createdAt: Long;
  updatedAt: Long;
  startedAt: Long;
  endedAt: Long;
  lastPingAt: Long;
  session: EngineSession | undefined;
}

export interface EngineSessionError {
  id: string;
  sessionId: string;
  runId: string;
  run: EngineSessionRun | undefined;
  session: EngineSession | undefined;
  errorCode: string;
  errorMessage: string;
  mcpError: McpError | undefined;
  metadata: { [key: string]: string };
  createdAt: Long;
}

export interface EngineSessionError_MetadataEntry {
  key: string;
  value: string;
}

export interface EngineSessionEvent {
  id: string;
  sessionId: string;
  runId: string;
  errorId: string;
  type: EngineSessionEventType;
  run: EngineSessionRun | undefined;
  session: EngineSession | undefined;
  error:
    | EngineSessionError
    | undefined;
  /** repeated string lines = 10; */
  metadata: { [key: string]: string };
  mcpOutput: McpOutput | undefined;
  createdAt: Long;
}

export interface EngineSessionEvent_MetadataEntry {
  key: string;
  value: string;
}

export interface EngineSessionMessage {
  id: string;
  index: number;
  sender: SessionMessageSender;
  sessionId: string;
  runId: string;
  run: EngineSessionRun | undefined;
  session: EngineSession | undefined;
  mcpMessage: McpMessage | undefined;
  metadata: { [key: string]: string };
  createdAt: Long;
}

export interface EngineSessionMessage_MetadataEntry {
  key: string;
  value: string;
}

export interface ListPagination {
  afterId: string;
  beforeId: string;
  limit: number;
  order: ListPaginationOrder;
}

export interface ListSessionsRequest {
  externalId: string;
  pagination: ListPagination | undefined;
}

export interface ListSessionsResponse {
  sessions: EngineSession[];
}

export interface GetSessionRequest {
  sessionId: string;
}

export interface GetSessionResponse {
  session: EngineSession | undefined;
}

export interface ListRunsRequest {
  sessionId: string;
  pagination: ListPagination | undefined;
}

export interface ListRunsResponse {
  runs: EngineSessionRun[];
}

export interface GetRunRequest {
  runId: string;
}

export interface GetRunResponse {
  run: EngineSessionRun | undefined;
}

export interface GetErrorRequest {
  errorId: string;
}

export interface GetErrorResponse {
  error: EngineSessionError | undefined;
}

export interface GetEventRequest {
  eventId: string;
}

export interface GetEventResponse {
  event: EngineSessionEvent | undefined;
}

export interface GetMessageRequest {
  messageId: string;
}

export interface GetMessageResponse {
  message: EngineSessionMessage | undefined;
}

export interface ListRunErrorsRequest {
  runId: string;
  pagination: ListPagination | undefined;
}

export interface ListRunErrorsResponse {
  errors: EngineSessionError[];
}

export interface ListRunEventsRequest {
  runId: string;
  pagination: ListPagination | undefined;
}

export interface ListRunEventsResponse {
  events: EngineSessionEvent[];
}

export interface ListRunMessagesRequest {
  runId: string;
  pagination: ListPagination | undefined;
}

export interface ListRunMessagesResponse {
  messages: EngineSessionMessage[];
}

export interface ListSessionEventsRequest {
  sessionId: string;
  pagination: ListPagination | undefined;
}

export interface ListSessionEventsResponse {
  events: EngineSessionEvent[];
}

export interface ListSessionErrorsRequest {
  sessionId: string;
  pagination: ListPagination | undefined;
}

export interface ListSessionErrorsResponse {
  errors: EngineSessionError[];
}

export interface ListSessionMessagesRequest {
  sessionId: string;
  pagination: ListPagination | undefined;
}

export interface ListSessionMessagesResponse {
  messages: EngineSessionMessage[];
}

export interface ListRecentlyActiveRunsRequest {
  since: Long;
}

export interface ListRecentlyActiveRunsResponse {
  runIds: string[];
}

export interface ListRecentlyActiveSessionsRequest {
  since: Long;
}

export interface ListRecentlyActiveSessionsResponse {
  sessionIds: string[];
}

function createBaseCreateSessionRequest(): CreateSessionRequest {
  return { sessionId: "", config: undefined, mcpClient: undefined, metadata: {} };
}

export const CreateSessionRequest: MessageFns<CreateSessionRequest> = {
  encode(message: CreateSessionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.config !== undefined) {
      SessionConfig.encode(message.config, writer.uint32(26).fork()).join();
    }
    if (message.mcpClient !== undefined) {
      McpParticipant.encode(message.mcpClient, writer.uint32(34).fork()).join();
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      CreateSessionRequest_MetadataEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateSessionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.config = SessionConfig.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.mcpClient = McpParticipant.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = CreateSessionRequest_MetadataEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.metadata[entry5.key] = entry5.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSessionRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      config: isSet(object.config) ? SessionConfig.fromJSON(object.config) : undefined,
      mcpClient: isSet(object.mcpClient) ? McpParticipant.fromJSON(object.mcpClient) : undefined,
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: CreateSessionRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.config !== undefined) {
      obj.config = SessionConfig.toJSON(message.config);
    }
    if (message.mcpClient !== undefined) {
      obj.mcpClient = McpParticipant.toJSON(message.mcpClient);
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<CreateSessionRequest>): CreateSessionRequest {
    return CreateSessionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateSessionRequest>): CreateSessionRequest {
    const message = createBaseCreateSessionRequest();
    message.sessionId = object.sessionId ?? "";
    message.config = (object.config !== undefined && object.config !== null)
      ? SessionConfig.fromPartial(object.config)
      : undefined;
    message.mcpClient = (object.mcpClient !== undefined && object.mcpClient !== null)
      ? McpParticipant.fromPartial(object.mcpClient)
      : undefined;
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseCreateSessionRequest_MetadataEntry(): CreateSessionRequest_MetadataEntry {
  return { key: "", value: "" };
}

export const CreateSessionRequest_MetadataEntry: MessageFns<CreateSessionRequest_MetadataEntry> = {
  encode(message: CreateSessionRequest_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateSessionRequest_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSessionRequest_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSessionRequest_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CreateSessionRequest_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateSessionRequest_MetadataEntry>): CreateSessionRequest_MetadataEntry {
    return CreateSessionRequest_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateSessionRequest_MetadataEntry>): CreateSessionRequest_MetadataEntry {
    const message = createBaseCreateSessionRequest_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseContainerRunConfigWithLauncher(): ContainerRunConfigWithLauncher {
  return { container: undefined, launcher: undefined };
}

export const ContainerRunConfigWithLauncher: MessageFns<ContainerRunConfigWithLauncher> = {
  encode(message: ContainerRunConfigWithLauncher, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.container !== undefined) {
      RunConfigContainer.encode(message.container, writer.uint32(10).fork()).join();
    }
    if (message.launcher !== undefined) {
      LauncherConfig.encode(message.launcher, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ContainerRunConfigWithLauncher {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseContainerRunConfigWithLauncher();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.container = RunConfigContainer.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.launcher = LauncherConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ContainerRunConfigWithLauncher {
    return {
      container: isSet(object.container) ? RunConfigContainer.fromJSON(object.container) : undefined,
      launcher: isSet(object.launcher) ? LauncherConfig.fromJSON(object.launcher) : undefined,
    };
  },

  toJSON(message: ContainerRunConfigWithLauncher): unknown {
    const obj: any = {};
    if (message.container !== undefined) {
      obj.container = RunConfigContainer.toJSON(message.container);
    }
    if (message.launcher !== undefined) {
      obj.launcher = LauncherConfig.toJSON(message.launcher);
    }
    return obj;
  },

  create(base?: DeepPartial<ContainerRunConfigWithLauncher>): ContainerRunConfigWithLauncher {
    return ContainerRunConfigWithLauncher.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ContainerRunConfigWithLauncher>): ContainerRunConfigWithLauncher {
    const message = createBaseContainerRunConfigWithLauncher();
    message.container = (object.container !== undefined && object.container !== null)
      ? RunConfigContainer.fromPartial(object.container)
      : undefined;
    message.launcher = (object.launcher !== undefined && object.launcher !== null)
      ? LauncherConfig.fromPartial(object.launcher)
      : undefined;
    return message;
  },
};

function createBaseRemoteRunConfigWithLauncher(): RemoteRunConfigWithLauncher {
  return { server: undefined, launcher: undefined };
}

export const RemoteRunConfigWithLauncher: MessageFns<RemoteRunConfigWithLauncher> = {
  encode(message: RemoteRunConfigWithLauncher, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.server !== undefined) {
      RunConfigRemoteServer.encode(message.server, writer.uint32(10).fork()).join();
    }
    if (message.launcher !== undefined) {
      LauncherConfig.encode(message.launcher, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RemoteRunConfigWithLauncher {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRemoteRunConfigWithLauncher();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.server = RunConfigRemoteServer.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.launcher = LauncherConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RemoteRunConfigWithLauncher {
    return {
      server: isSet(object.server) ? RunConfigRemoteServer.fromJSON(object.server) : undefined,
      launcher: isSet(object.launcher) ? LauncherConfig.fromJSON(object.launcher) : undefined,
    };
  },

  toJSON(message: RemoteRunConfigWithLauncher): unknown {
    const obj: any = {};
    if (message.server !== undefined) {
      obj.server = RunConfigRemoteServer.toJSON(message.server);
    }
    if (message.launcher !== undefined) {
      obj.launcher = LauncherConfig.toJSON(message.launcher);
    }
    return obj;
  },

  create(base?: DeepPartial<RemoteRunConfigWithLauncher>): RemoteRunConfigWithLauncher {
    return RemoteRunConfigWithLauncher.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<RemoteRunConfigWithLauncher>): RemoteRunConfigWithLauncher {
    const message = createBaseRemoteRunConfigWithLauncher();
    message.server = (object.server !== undefined && object.server !== null)
      ? RunConfigRemoteServer.fromPartial(object.server)
      : undefined;
    message.launcher = (object.launcher !== undefined && object.launcher !== null)
      ? LauncherConfig.fromPartial(object.launcher)
      : undefined;
    return message;
  },
};

function createBaseSessionConfig(): SessionConfig {
  return {
    containerRunConfigWithLauncher: undefined,
    containerRunConfigWithContainerArguments: undefined,
    remoteRunConfigWithLauncher: undefined,
    remoteRunConfigWithServer: undefined,
  };
}

export const SessionConfig: MessageFns<SessionConfig> = {
  encode(message: SessionConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.containerRunConfigWithLauncher !== undefined) {
      ContainerRunConfigWithLauncher.encode(message.containerRunConfigWithLauncher, writer.uint32(10).fork()).join();
    }
    if (message.containerRunConfigWithContainerArguments !== undefined) {
      RunConfig.encode(message.containerRunConfigWithContainerArguments, writer.uint32(18).fork()).join();
    }
    if (message.remoteRunConfigWithLauncher !== undefined) {
      RemoteRunConfigWithLauncher.encode(message.remoteRunConfigWithLauncher, writer.uint32(26).fork()).join();
    }
    if (message.remoteRunConfigWithServer !== undefined) {
      RunConfig1.encode(message.remoteRunConfigWithServer, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SessionConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.containerRunConfigWithLauncher = ContainerRunConfigWithLauncher.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.containerRunConfigWithContainerArguments = RunConfig.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.remoteRunConfigWithLauncher = RemoteRunConfigWithLauncher.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.remoteRunConfigWithServer = RunConfig1.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionConfig {
    return {
      containerRunConfigWithLauncher: isSet(object.containerRunConfigWithLauncher)
        ? ContainerRunConfigWithLauncher.fromJSON(object.containerRunConfigWithLauncher)
        : undefined,
      containerRunConfigWithContainerArguments: isSet(object.containerRunConfigWithContainerArguments)
        ? RunConfig.fromJSON(object.containerRunConfigWithContainerArguments)
        : undefined,
      remoteRunConfigWithLauncher: isSet(object.remoteRunConfigWithLauncher)
        ? RemoteRunConfigWithLauncher.fromJSON(object.remoteRunConfigWithLauncher)
        : undefined,
      remoteRunConfigWithServer: isSet(object.remoteRunConfigWithServer)
        ? RunConfig1.fromJSON(object.remoteRunConfigWithServer)
        : undefined,
    };
  },

  toJSON(message: SessionConfig): unknown {
    const obj: any = {};
    if (message.containerRunConfigWithLauncher !== undefined) {
      obj.containerRunConfigWithLauncher = ContainerRunConfigWithLauncher.toJSON(
        message.containerRunConfigWithLauncher,
      );
    }
    if (message.containerRunConfigWithContainerArguments !== undefined) {
      obj.containerRunConfigWithContainerArguments = RunConfig.toJSON(message.containerRunConfigWithContainerArguments);
    }
    if (message.remoteRunConfigWithLauncher !== undefined) {
      obj.remoteRunConfigWithLauncher = RemoteRunConfigWithLauncher.toJSON(message.remoteRunConfigWithLauncher);
    }
    if (message.remoteRunConfigWithServer !== undefined) {
      obj.remoteRunConfigWithServer = RunConfig1.toJSON(message.remoteRunConfigWithServer);
    }
    return obj;
  },

  create(base?: DeepPartial<SessionConfig>): SessionConfig {
    return SessionConfig.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SessionConfig>): SessionConfig {
    const message = createBaseSessionConfig();
    message.containerRunConfigWithLauncher =
      (object.containerRunConfigWithLauncher !== undefined && object.containerRunConfigWithLauncher !== null)
        ? ContainerRunConfigWithLauncher.fromPartial(object.containerRunConfigWithLauncher)
        : undefined;
    message.containerRunConfigWithContainerArguments =
      (object.containerRunConfigWithContainerArguments !== undefined &&
          object.containerRunConfigWithContainerArguments !== null)
        ? RunConfig.fromPartial(object.containerRunConfigWithContainerArguments)
        : undefined;
    message.remoteRunConfigWithLauncher =
      (object.remoteRunConfigWithLauncher !== undefined && object.remoteRunConfigWithLauncher !== null)
        ? RemoteRunConfigWithLauncher.fromPartial(object.remoteRunConfigWithLauncher)
        : undefined;
    message.remoteRunConfigWithServer =
      (object.remoteRunConfigWithServer !== undefined && object.remoteRunConfigWithServer !== null)
        ? RunConfig1.fromPartial(object.remoteRunConfigWithServer)
        : undefined;
    return message;
  },
};

function createBaseCreateSessionResponse(): CreateSessionResponse {
  return { sessionId: "", session: undefined };
}

export const CreateSessionResponse: MessageFns<CreateSessionResponse> = {
  encode(message: CreateSessionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.session !== undefined) {
      EngineSession.encode(message.session, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateSessionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.session = EngineSession.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateSessionResponse {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      session: isSet(object.session) ? EngineSession.fromJSON(object.session) : undefined,
    };
  },

  toJSON(message: CreateSessionResponse): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.session !== undefined) {
      obj.session = EngineSession.toJSON(message.session);
    }
    return obj;
  },

  create(base?: DeepPartial<CreateSessionResponse>): CreateSessionResponse {
    return CreateSessionResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateSessionResponse>): CreateSessionResponse {
    const message = createBaseCreateSessionResponse();
    message.sessionId = object.sessionId ?? "";
    message.session = (object.session !== undefined && object.session !== null)
      ? EngineSession.fromPartial(object.session)
      : undefined;
    return message;
  },
};

function createBaseSendMcpMessageRequest(): SendMcpMessageRequest {
  return { sessionId: "", mcpMessages: [], includeResponses: false };
}

export const SendMcpMessageRequest: MessageFns<SendMcpMessageRequest> = {
  encode(message: SendMcpMessageRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    for (const v of message.mcpMessages) {
      McpMessageRaw.encode(v!, writer.uint32(18).fork()).join();
    }
    if (message.includeResponses !== false) {
      writer.uint32(24).bool(message.includeResponses);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendMcpMessageRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendMcpMessageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.mcpMessages.push(McpMessageRaw.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.includeResponses = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendMcpMessageRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      mcpMessages: globalThis.Array.isArray(object?.mcpMessages)
        ? object.mcpMessages.map((e: any) => McpMessageRaw.fromJSON(e))
        : [],
      includeResponses: isSet(object.includeResponses) ? globalThis.Boolean(object.includeResponses) : false,
    };
  },

  toJSON(message: SendMcpMessageRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.mcpMessages?.length) {
      obj.mcpMessages = message.mcpMessages.map((e) => McpMessageRaw.toJSON(e));
    }
    if (message.includeResponses !== false) {
      obj.includeResponses = message.includeResponses;
    }
    return obj;
  },

  create(base?: DeepPartial<SendMcpMessageRequest>): SendMcpMessageRequest {
    return SendMcpMessageRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SendMcpMessageRequest>): SendMcpMessageRequest {
    const message = createBaseSendMcpMessageRequest();
    message.sessionId = object.sessionId ?? "";
    message.mcpMessages = object.mcpMessages?.map((e) => McpMessageRaw.fromPartial(e)) || [];
    message.includeResponses = object.includeResponses ?? false;
    return message;
  },
};

function createBaseSendMcpMessageResponse(): SendMcpMessageResponse {
  return { mcpMessage: undefined, mcpError: undefined, sessionEvent: undefined };
}

export const SendMcpMessageResponse: MessageFns<SendMcpMessageResponse> = {
  encode(message: SendMcpMessageResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mcpMessage !== undefined) {
      McpMessage.encode(message.mcpMessage, writer.uint32(10).fork()).join();
    }
    if (message.mcpError !== undefined) {
      McpError.encode(message.mcpError, writer.uint32(18).fork()).join();
    }
    if (message.sessionEvent !== undefined) {
      SessionEvent.encode(message.sessionEvent, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SendMcpMessageResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSendMcpMessageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mcpMessage = McpMessage.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.mcpError = McpError.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sessionEvent = SessionEvent.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SendMcpMessageResponse {
    return {
      mcpMessage: isSet(object.mcpMessage) ? McpMessage.fromJSON(object.mcpMessage) : undefined,
      mcpError: isSet(object.mcpError) ? McpError.fromJSON(object.mcpError) : undefined,
      sessionEvent: isSet(object.sessionEvent) ? SessionEvent.fromJSON(object.sessionEvent) : undefined,
    };
  },

  toJSON(message: SendMcpMessageResponse): unknown {
    const obj: any = {};
    if (message.mcpMessage !== undefined) {
      obj.mcpMessage = McpMessage.toJSON(message.mcpMessage);
    }
    if (message.mcpError !== undefined) {
      obj.mcpError = McpError.toJSON(message.mcpError);
    }
    if (message.sessionEvent !== undefined) {
      obj.sessionEvent = SessionEvent.toJSON(message.sessionEvent);
    }
    return obj;
  },

  create(base?: DeepPartial<SendMcpMessageResponse>): SendMcpMessageResponse {
    return SendMcpMessageResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SendMcpMessageResponse>): SendMcpMessageResponse {
    const message = createBaseSendMcpMessageResponse();
    message.mcpMessage = (object.mcpMessage !== undefined && object.mcpMessage !== null)
      ? McpMessage.fromPartial(object.mcpMessage)
      : undefined;
    message.mcpError = (object.mcpError !== undefined && object.mcpError !== null)
      ? McpError.fromPartial(object.mcpError)
      : undefined;
    message.sessionEvent = (object.sessionEvent !== undefined && object.sessionEvent !== null)
      ? SessionEvent.fromPartial(object.sessionEvent)
      : undefined;
    return message;
  },
};

function createBaseStreamMcpMessagesRequest(): StreamMcpMessagesRequest {
  return { sessionId: "", onlyMessageTypes: [], onlyIds: [], replayAfterUuid: "" };
}

export const StreamMcpMessagesRequest: MessageFns<StreamMcpMessagesRequest> = {
  encode(message: StreamMcpMessagesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    writer.uint32(18).fork();
    for (const v of message.onlyMessageTypes) {
      writer.int32(v);
    }
    writer.join();
    for (const v of message.onlyIds) {
      writer.uint32(26).string(v!);
    }
    if (message.replayAfterUuid !== "") {
      writer.uint32(34).string(message.replayAfterUuid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamMcpMessagesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamMcpMessagesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag === 16) {
            message.onlyMessageTypes.push(reader.int32() as any);

            continue;
          }

          if (tag === 18) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.onlyMessageTypes.push(reader.int32() as any);
            }

            continue;
          }

          break;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.onlyIds.push(reader.string());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.replayAfterUuid = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamMcpMessagesRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      onlyMessageTypes: globalThis.Array.isArray(object?.onlyMessageTypes)
        ? object.onlyMessageTypes.map((e: any) => mcpMessageTypeFromJSON(e))
        : [],
      onlyIds: globalThis.Array.isArray(object?.onlyIds) ? object.onlyIds.map((e: any) => globalThis.String(e)) : [],
      replayAfterUuid: isSet(object.replayAfterUuid) ? globalThis.String(object.replayAfterUuid) : "",
    };
  },

  toJSON(message: StreamMcpMessagesRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.onlyMessageTypes?.length) {
      obj.onlyMessageTypes = message.onlyMessageTypes.map((e) => mcpMessageTypeToJSON(e));
    }
    if (message.onlyIds?.length) {
      obj.onlyIds = message.onlyIds;
    }
    if (message.replayAfterUuid !== "") {
      obj.replayAfterUuid = message.replayAfterUuid;
    }
    return obj;
  },

  create(base?: DeepPartial<StreamMcpMessagesRequest>): StreamMcpMessagesRequest {
    return StreamMcpMessagesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamMcpMessagesRequest>): StreamMcpMessagesRequest {
    const message = createBaseStreamMcpMessagesRequest();
    message.sessionId = object.sessionId ?? "";
    message.onlyMessageTypes = object.onlyMessageTypes?.map((e) => e) || [];
    message.onlyIds = object.onlyIds?.map((e) => e) || [];
    message.replayAfterUuid = object.replayAfterUuid ?? "";
    return message;
  },
};

function createBaseSessionEventInfoRun(): SessionEventInfoRun {
  return { run: undefined };
}

export const SessionEventInfoRun: MessageFns<SessionEventInfoRun> = {
  encode(message: SessionEventInfoRun, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.run !== undefined) {
      EngineSessionRun.encode(message.run, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SessionEventInfoRun {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionEventInfoRun();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.run = EngineSessionRun.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionEventInfoRun {
    return { run: isSet(object.run) ? EngineSessionRun.fromJSON(object.run) : undefined };
  },

  toJSON(message: SessionEventInfoRun): unknown {
    const obj: any = {};
    if (message.run !== undefined) {
      obj.run = EngineSessionRun.toJSON(message.run);
    }
    return obj;
  },

  create(base?: DeepPartial<SessionEventInfoRun>): SessionEventInfoRun {
    return SessionEventInfoRun.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SessionEventInfoRun>): SessionEventInfoRun {
    const message = createBaseSessionEventInfoRun();
    message.run = (object.run !== undefined && object.run !== null)
      ? EngineSessionRun.fromPartial(object.run)
      : undefined;
    return message;
  },
};

function createBaseSessionEventInfoSession(): SessionEventInfoSession {
  return { session: undefined };
}

export const SessionEventInfoSession: MessageFns<SessionEventInfoSession> = {
  encode(message: SessionEventInfoSession, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.session !== undefined) {
      EngineSession.encode(message.session, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SessionEventInfoSession {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionEventInfoSession();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.session = EngineSession.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionEventInfoSession {
    return { session: isSet(object.session) ? EngineSession.fromJSON(object.session) : undefined };
  },

  toJSON(message: SessionEventInfoSession): unknown {
    const obj: any = {};
    if (message.session !== undefined) {
      obj.session = EngineSession.toJSON(message.session);
    }
    return obj;
  },

  create(base?: DeepPartial<SessionEventInfoSession>): SessionEventInfoSession {
    return SessionEventInfoSession.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SessionEventInfoSession>): SessionEventInfoSession {
    const message = createBaseSessionEventInfoSession();
    message.session = (object.session !== undefined && object.session !== null)
      ? EngineSession.fromPartial(object.session)
      : undefined;
    return message;
  },
};

function createBaseSessionEventStartRun(): SessionEventStartRun {
  return { run: undefined };
}

export const SessionEventStartRun: MessageFns<SessionEventStartRun> = {
  encode(message: SessionEventStartRun, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.run !== undefined) {
      EngineSessionRun.encode(message.run, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SessionEventStartRun {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionEventStartRun();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.run = EngineSessionRun.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionEventStartRun {
    return { run: isSet(object.run) ? EngineSessionRun.fromJSON(object.run) : undefined };
  },

  toJSON(message: SessionEventStartRun): unknown {
    const obj: any = {};
    if (message.run !== undefined) {
      obj.run = EngineSessionRun.toJSON(message.run);
    }
    return obj;
  },

  create(base?: DeepPartial<SessionEventStartRun>): SessionEventStartRun {
    return SessionEventStartRun.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SessionEventStartRun>): SessionEventStartRun {
    const message = createBaseSessionEventStartRun();
    message.run = (object.run !== undefined && object.run !== null)
      ? EngineSessionRun.fromPartial(object.run)
      : undefined;
    return message;
  },
};

function createBaseSessionEventStopRun(): SessionEventStopRun {
  return { run: undefined };
}

export const SessionEventStopRun: MessageFns<SessionEventStopRun> = {
  encode(message: SessionEventStopRun, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.run !== undefined) {
      EngineSessionRun.encode(message.run, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SessionEventStopRun {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionEventStopRun();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.run = EngineSessionRun.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionEventStopRun {
    return { run: isSet(object.run) ? EngineSessionRun.fromJSON(object.run) : undefined };
  },

  toJSON(message: SessionEventStopRun): unknown {
    const obj: any = {};
    if (message.run !== undefined) {
      obj.run = EngineSessionRun.toJSON(message.run);
    }
    return obj;
  },

  create(base?: DeepPartial<SessionEventStopRun>): SessionEventStopRun {
    return SessionEventStopRun.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SessionEventStopRun>): SessionEventStopRun {
    const message = createBaseSessionEventStopRun();
    message.run = (object.run !== undefined && object.run !== null)
      ? EngineSessionRun.fromPartial(object.run)
      : undefined;
    return message;
  },
};

function createBaseSessionEvent(): SessionEvent {
  return { startRun: undefined, stopRun: undefined, infoRun: undefined, infoSession: undefined };
}

export const SessionEvent: MessageFns<SessionEvent> = {
  encode(message: SessionEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startRun !== undefined) {
      SessionEventStartRun.encode(message.startRun, writer.uint32(10).fork()).join();
    }
    if (message.stopRun !== undefined) {
      SessionEventStopRun.encode(message.stopRun, writer.uint32(18).fork()).join();
    }
    if (message.infoRun !== undefined) {
      SessionEventInfoRun.encode(message.infoRun, writer.uint32(26).fork()).join();
    }
    if (message.infoSession !== undefined) {
      SessionEventInfoSession.encode(message.infoSession, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SessionEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSessionEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.startRun = SessionEventStartRun.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.stopRun = SessionEventStopRun.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.infoRun = SessionEventInfoRun.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.infoSession = SessionEventInfoSession.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SessionEvent {
    return {
      startRun: isSet(object.startRun) ? SessionEventStartRun.fromJSON(object.startRun) : undefined,
      stopRun: isSet(object.stopRun) ? SessionEventStopRun.fromJSON(object.stopRun) : undefined,
      infoRun: isSet(object.infoRun) ? SessionEventInfoRun.fromJSON(object.infoRun) : undefined,
      infoSession: isSet(object.infoSession) ? SessionEventInfoSession.fromJSON(object.infoSession) : undefined,
    };
  },

  toJSON(message: SessionEvent): unknown {
    const obj: any = {};
    if (message.startRun !== undefined) {
      obj.startRun = SessionEventStartRun.toJSON(message.startRun);
    }
    if (message.stopRun !== undefined) {
      obj.stopRun = SessionEventStopRun.toJSON(message.stopRun);
    }
    if (message.infoRun !== undefined) {
      obj.infoRun = SessionEventInfoRun.toJSON(message.infoRun);
    }
    if (message.infoSession !== undefined) {
      obj.infoSession = SessionEventInfoSession.toJSON(message.infoSession);
    }
    return obj;
  },

  create(base?: DeepPartial<SessionEvent>): SessionEvent {
    return SessionEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<SessionEvent>): SessionEvent {
    const message = createBaseSessionEvent();
    message.startRun = (object.startRun !== undefined && object.startRun !== null)
      ? SessionEventStartRun.fromPartial(object.startRun)
      : undefined;
    message.stopRun = (object.stopRun !== undefined && object.stopRun !== null)
      ? SessionEventStopRun.fromPartial(object.stopRun)
      : undefined;
    message.infoRun = (object.infoRun !== undefined && object.infoRun !== null)
      ? SessionEventInfoRun.fromPartial(object.infoRun)
      : undefined;
    message.infoSession = (object.infoSession !== undefined && object.infoSession !== null)
      ? SessionEventInfoSession.fromPartial(object.infoSession)
      : undefined;
    return message;
  },
};

function createBaseStreamMcpMessagesResponse(): StreamMcpMessagesResponse {
  return { mcpMessage: undefined, mcpError: undefined, mcpOutput: undefined, sessionEvent: undefined, isReplay: false };
}

export const StreamMcpMessagesResponse: MessageFns<StreamMcpMessagesResponse> = {
  encode(message: StreamMcpMessagesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mcpMessage !== undefined) {
      McpMessage.encode(message.mcpMessage, writer.uint32(10).fork()).join();
    }
    if (message.mcpError !== undefined) {
      McpError.encode(message.mcpError, writer.uint32(18).fork()).join();
    }
    if (message.mcpOutput !== undefined) {
      McpOutput.encode(message.mcpOutput, writer.uint32(26).fork()).join();
    }
    if (message.sessionEvent !== undefined) {
      SessionEvent.encode(message.sessionEvent, writer.uint32(34).fork()).join();
    }
    if (message.isReplay !== false) {
      writer.uint32(80).bool(message.isReplay);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamMcpMessagesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStreamMcpMessagesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mcpMessage = McpMessage.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.mcpError = McpError.decode(reader, reader.uint32());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.mcpOutput = McpOutput.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sessionEvent = SessionEvent.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.isReplay = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StreamMcpMessagesResponse {
    return {
      mcpMessage: isSet(object.mcpMessage) ? McpMessage.fromJSON(object.mcpMessage) : undefined,
      mcpError: isSet(object.mcpError) ? McpError.fromJSON(object.mcpError) : undefined,
      mcpOutput: isSet(object.mcpOutput) ? McpOutput.fromJSON(object.mcpOutput) : undefined,
      sessionEvent: isSet(object.sessionEvent) ? SessionEvent.fromJSON(object.sessionEvent) : undefined,
      isReplay: isSet(object.isReplay) ? globalThis.Boolean(object.isReplay) : false,
    };
  },

  toJSON(message: StreamMcpMessagesResponse): unknown {
    const obj: any = {};
    if (message.mcpMessage !== undefined) {
      obj.mcpMessage = McpMessage.toJSON(message.mcpMessage);
    }
    if (message.mcpError !== undefined) {
      obj.mcpError = McpError.toJSON(message.mcpError);
    }
    if (message.mcpOutput !== undefined) {
      obj.mcpOutput = McpOutput.toJSON(message.mcpOutput);
    }
    if (message.sessionEvent !== undefined) {
      obj.sessionEvent = SessionEvent.toJSON(message.sessionEvent);
    }
    if (message.isReplay !== false) {
      obj.isReplay = message.isReplay;
    }
    return obj;
  },

  create(base?: DeepPartial<StreamMcpMessagesResponse>): StreamMcpMessagesResponse {
    return StreamMcpMessagesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<StreamMcpMessagesResponse>): StreamMcpMessagesResponse {
    const message = createBaseStreamMcpMessagesResponse();
    message.mcpMessage = (object.mcpMessage !== undefined && object.mcpMessage !== null)
      ? McpMessage.fromPartial(object.mcpMessage)
      : undefined;
    message.mcpError = (object.mcpError !== undefined && object.mcpError !== null)
      ? McpError.fromPartial(object.mcpError)
      : undefined;
    message.mcpOutput = (object.mcpOutput !== undefined && object.mcpOutput !== null)
      ? McpOutput.fromPartial(object.mcpOutput)
      : undefined;
    message.sessionEvent = (object.sessionEvent !== undefined && object.sessionEvent !== null)
      ? SessionEvent.fromPartial(object.sessionEvent)
      : undefined;
    message.isReplay = object.isReplay ?? false;
    return message;
  },
};

function createBaseGetServerInfoRequest(): GetServerInfoRequest {
  return { sessionId: "" };
}

export const GetServerInfoRequest: MessageFns<GetServerInfoRequest> = {
  encode(message: GetServerInfoRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetServerInfoRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetServerInfoRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetServerInfoRequest {
    return { sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "" };
  },

  toJSON(message: GetServerInfoRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetServerInfoRequest>): GetServerInfoRequest {
    return GetServerInfoRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetServerInfoRequest>): GetServerInfoRequest {
    const message = createBaseGetServerInfoRequest();
    message.sessionId = object.sessionId ?? "";
    return message;
  },
};

function createBaseListWorkersRequest(): ListWorkersRequest {
  return {};
}

export const ListWorkersRequest: MessageFns<ListWorkersRequest> = {
  encode(_: ListWorkersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListWorkersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListWorkersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ListWorkersRequest {
    return {};
  },

  toJSON(_: ListWorkersRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<ListWorkersRequest>): ListWorkersRequest {
    return ListWorkersRequest.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<ListWorkersRequest>): ListWorkersRequest {
    const message = createBaseListWorkersRequest();
    return message;
  },
};

function createBaseListWorkersResponse(): ListWorkersResponse {
  return { workers: [] };
}

export const ListWorkersResponse: MessageFns<ListWorkersResponse> = {
  encode(message: ListWorkersResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.workers) {
      WorkerInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListWorkersResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListWorkersResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.workers.push(WorkerInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListWorkersResponse {
    return {
      workers: globalThis.Array.isArray(object?.workers) ? object.workers.map((e: any) => WorkerInfo.fromJSON(e)) : [],
    };
  },

  toJSON(message: ListWorkersResponse): unknown {
    const obj: any = {};
    if (message.workers?.length) {
      obj.workers = message.workers.map((e) => WorkerInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ListWorkersResponse>): ListWorkersResponse {
    return ListWorkersResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListWorkersResponse>): ListWorkersResponse {
    const message = createBaseListWorkersResponse();
    message.workers = object.workers?.map((e) => WorkerInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseWorkerInfo(): WorkerInfo {
  return { workerId: "", address: "", acceptingRuns: false, healthy: false };
}

export const WorkerInfo: MessageFns<WorkerInfo> = {
  encode(message: WorkerInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.workerId !== "") {
      writer.uint32(10).string(message.workerId);
    }
    if (message.address !== "") {
      writer.uint32(18).string(message.address);
    }
    if (message.acceptingRuns !== false) {
      writer.uint32(24).bool(message.acceptingRuns);
    }
    if (message.healthy !== false) {
      writer.uint32(32).bool(message.healthy);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkerInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkerInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.workerId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.address = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.acceptingRuns = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.healthy = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkerInfo {
    return {
      workerId: isSet(object.workerId) ? globalThis.String(object.workerId) : "",
      address: isSet(object.address) ? globalThis.String(object.address) : "",
      acceptingRuns: isSet(object.acceptingRuns) ? globalThis.Boolean(object.acceptingRuns) : false,
      healthy: isSet(object.healthy) ? globalThis.Boolean(object.healthy) : false,
    };
  },

  toJSON(message: WorkerInfo): unknown {
    const obj: any = {};
    if (message.workerId !== "") {
      obj.workerId = message.workerId;
    }
    if (message.address !== "") {
      obj.address = message.address;
    }
    if (message.acceptingRuns !== false) {
      obj.acceptingRuns = message.acceptingRuns;
    }
    if (message.healthy !== false) {
      obj.healthy = message.healthy;
    }
    return obj;
  },

  create(base?: DeepPartial<WorkerInfo>): WorkerInfo {
    return WorkerInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<WorkerInfo>): WorkerInfo {
    const message = createBaseWorkerInfo();
    message.workerId = object.workerId ?? "";
    message.address = object.address ?? "";
    message.acceptingRuns = object.acceptingRuns ?? false;
    message.healthy = object.healthy ?? false;
    return message;
  },
};

function createBaseDiscardSessionRequest(): DiscardSessionRequest {
  return { sessionId: "" };
}

export const DiscardSessionRequest: MessageFns<DiscardSessionRequest> = {
  encode(message: DiscardSessionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DiscardSessionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDiscardSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DiscardSessionRequest {
    return { sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "" };
  },

  toJSON(message: DiscardSessionRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    return obj;
  },

  create(base?: DeepPartial<DiscardSessionRequest>): DiscardSessionRequest {
    return DiscardSessionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<DiscardSessionRequest>): DiscardSessionRequest {
    const message = createBaseDiscardSessionRequest();
    message.sessionId = object.sessionId ?? "";
    return message;
  },
};

function createBaseDiscardSessionResponse(): DiscardSessionResponse {
  return {};
}

export const DiscardSessionResponse: MessageFns<DiscardSessionResponse> = {
  encode(_: DiscardSessionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DiscardSessionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDiscardSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): DiscardSessionResponse {
    return {};
  },

  toJSON(_: DiscardSessionResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<DiscardSessionResponse>): DiscardSessionResponse {
    return DiscardSessionResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<DiscardSessionResponse>): DiscardSessionResponse {
    const message = createBaseDiscardSessionResponse();
    return message;
  },
};

function createBaseEngineSession(): EngineSession {
  return {
    id: "",
    externalId: "",
    type: 0,
    status: 0,
    hasError: false,
    mcpClient: undefined,
    mcpServer: undefined,
    createdAt: Long.ZERO,
    updatedAt: Long.ZERO,
    startedAt: Long.ZERO,
    endedAt: Long.ZERO,
    lastPingAt: Long.ZERO,
  };
}

export const EngineSession: MessageFns<EngineSession> = {
  encode(message: EngineSession, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.externalId !== "") {
      writer.uint32(18).string(message.externalId);
    }
    if (message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    if (message.status !== 0) {
      writer.uint32(32).int32(message.status);
    }
    if (message.hasError !== false) {
      writer.uint32(96).bool(message.hasError);
    }
    if (message.mcpClient !== undefined) {
      McpParticipant.encode(message.mcpClient, writer.uint32(42).fork()).join();
    }
    if (message.mcpServer !== undefined) {
      McpParticipant.encode(message.mcpServer, writer.uint32(50).fork()).join();
    }
    if (!message.createdAt.equals(Long.ZERO)) {
      writer.uint32(56).int64(message.createdAt.toString());
    }
    if (!message.updatedAt.equals(Long.ZERO)) {
      writer.uint32(64).int64(message.updatedAt.toString());
    }
    if (!message.startedAt.equals(Long.ZERO)) {
      writer.uint32(72).int64(message.startedAt.toString());
    }
    if (!message.endedAt.equals(Long.ZERO)) {
      writer.uint32(80).int64(message.endedAt.toString());
    }
    if (!message.lastPingAt.equals(Long.ZERO)) {
      writer.uint32(88).int64(message.lastPingAt.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EngineSession {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEngineSession();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.externalId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.hasError = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.mcpClient = McpParticipant.decode(reader, reader.uint32());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.mcpServer = McpParticipant.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.createdAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.updatedAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.startedAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.endedAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.lastPingAt = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EngineSession {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      externalId: isSet(object.externalId) ? globalThis.String(object.externalId) : "",
      type: isSet(object.type) ? engineSessionTypeFromJSON(object.type) : 0,
      status: isSet(object.status) ? engineSessionStatusFromJSON(object.status) : 0,
      hasError: isSet(object.hasError) ? globalThis.Boolean(object.hasError) : false,
      mcpClient: isSet(object.mcpClient) ? McpParticipant.fromJSON(object.mcpClient) : undefined,
      mcpServer: isSet(object.mcpServer) ? McpParticipant.fromJSON(object.mcpServer) : undefined,
      createdAt: isSet(object.createdAt) ? Long.fromValue(object.createdAt) : Long.ZERO,
      updatedAt: isSet(object.updatedAt) ? Long.fromValue(object.updatedAt) : Long.ZERO,
      startedAt: isSet(object.startedAt) ? Long.fromValue(object.startedAt) : Long.ZERO,
      endedAt: isSet(object.endedAt) ? Long.fromValue(object.endedAt) : Long.ZERO,
      lastPingAt: isSet(object.lastPingAt) ? Long.fromValue(object.lastPingAt) : Long.ZERO,
    };
  },

  toJSON(message: EngineSession): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.externalId !== "") {
      obj.externalId = message.externalId;
    }
    if (message.type !== 0) {
      obj.type = engineSessionTypeToJSON(message.type);
    }
    if (message.status !== 0) {
      obj.status = engineSessionStatusToJSON(message.status);
    }
    if (message.hasError !== false) {
      obj.hasError = message.hasError;
    }
    if (message.mcpClient !== undefined) {
      obj.mcpClient = McpParticipant.toJSON(message.mcpClient);
    }
    if (message.mcpServer !== undefined) {
      obj.mcpServer = McpParticipant.toJSON(message.mcpServer);
    }
    if (!message.createdAt.equals(Long.ZERO)) {
      obj.createdAt = (message.createdAt || Long.ZERO).toString();
    }
    if (!message.updatedAt.equals(Long.ZERO)) {
      obj.updatedAt = (message.updatedAt || Long.ZERO).toString();
    }
    if (!message.startedAt.equals(Long.ZERO)) {
      obj.startedAt = (message.startedAt || Long.ZERO).toString();
    }
    if (!message.endedAt.equals(Long.ZERO)) {
      obj.endedAt = (message.endedAt || Long.ZERO).toString();
    }
    if (!message.lastPingAt.equals(Long.ZERO)) {
      obj.lastPingAt = (message.lastPingAt || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<EngineSession>): EngineSession {
    return EngineSession.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EngineSession>): EngineSession {
    const message = createBaseEngineSession();
    message.id = object.id ?? "";
    message.externalId = object.externalId ?? "";
    message.type = object.type ?? 0;
    message.status = object.status ?? 0;
    message.hasError = object.hasError ?? false;
    message.mcpClient = (object.mcpClient !== undefined && object.mcpClient !== null)
      ? McpParticipant.fromPartial(object.mcpClient)
      : undefined;
    message.mcpServer = (object.mcpServer !== undefined && object.mcpServer !== null)
      ? McpParticipant.fromPartial(object.mcpServer)
      : undefined;
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Long.fromValue(object.createdAt)
      : Long.ZERO;
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Long.fromValue(object.updatedAt)
      : Long.ZERO;
    message.startedAt = (object.startedAt !== undefined && object.startedAt !== null)
      ? Long.fromValue(object.startedAt)
      : Long.ZERO;
    message.endedAt = (object.endedAt !== undefined && object.endedAt !== null)
      ? Long.fromValue(object.endedAt)
      : Long.ZERO;
    message.lastPingAt = (object.lastPingAt !== undefined && object.lastPingAt !== null)
      ? Long.fromValue(object.lastPingAt)
      : Long.ZERO;
    return message;
  },
};

function createBaseEngineSessionRun(): EngineSessionRun {
  return {
    id: "",
    sessionId: "",
    type: 0,
    status: 0,
    hasError: false,
    workerId: "",
    createdAt: Long.ZERO,
    updatedAt: Long.ZERO,
    startedAt: Long.ZERO,
    endedAt: Long.ZERO,
    lastPingAt: Long.ZERO,
    session: undefined,
  };
}

export const EngineSessionRun: MessageFns<EngineSessionRun> = {
  encode(message: EngineSessionRun, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.sessionId !== "") {
      writer.uint32(18).string(message.sessionId);
    }
    if (message.type !== 0) {
      writer.uint32(24).int32(message.type);
    }
    if (message.status !== 0) {
      writer.uint32(32).int32(message.status);
    }
    if (message.hasError !== false) {
      writer.uint32(40).bool(message.hasError);
    }
    if (message.workerId !== "") {
      writer.uint32(50).string(message.workerId);
    }
    if (!message.createdAt.equals(Long.ZERO)) {
      writer.uint32(56).int64(message.createdAt.toString());
    }
    if (!message.updatedAt.equals(Long.ZERO)) {
      writer.uint32(64).int64(message.updatedAt.toString());
    }
    if (!message.startedAt.equals(Long.ZERO)) {
      writer.uint32(72).int64(message.startedAt.toString());
    }
    if (!message.endedAt.equals(Long.ZERO)) {
      writer.uint32(80).int64(message.endedAt.toString());
    }
    if (!message.lastPingAt.equals(Long.ZERO)) {
      writer.uint32(88).int64(message.lastPingAt.toString());
    }
    if (message.session !== undefined) {
      EngineSession.encode(message.session, writer.uint32(98).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EngineSessionRun {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEngineSessionRun();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.status = reader.int32() as any;
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.hasError = reader.bool();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.workerId = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.createdAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.updatedAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.startedAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.endedAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 11: {
          if (tag !== 88) {
            break;
          }

          message.lastPingAt = Long.fromString(reader.int64().toString());
          continue;
        }
        case 12: {
          if (tag !== 98) {
            break;
          }

          message.session = EngineSession.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EngineSessionRun {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      type: isSet(object.type) ? engineRunTypeFromJSON(object.type) : 0,
      status: isSet(object.status) ? engineRunStatusFromJSON(object.status) : 0,
      hasError: isSet(object.hasError) ? globalThis.Boolean(object.hasError) : false,
      workerId: isSet(object.workerId) ? globalThis.String(object.workerId) : "",
      createdAt: isSet(object.createdAt) ? Long.fromValue(object.createdAt) : Long.ZERO,
      updatedAt: isSet(object.updatedAt) ? Long.fromValue(object.updatedAt) : Long.ZERO,
      startedAt: isSet(object.startedAt) ? Long.fromValue(object.startedAt) : Long.ZERO,
      endedAt: isSet(object.endedAt) ? Long.fromValue(object.endedAt) : Long.ZERO,
      lastPingAt: isSet(object.lastPingAt) ? Long.fromValue(object.lastPingAt) : Long.ZERO,
      session: isSet(object.session) ? EngineSession.fromJSON(object.session) : undefined,
    };
  },

  toJSON(message: EngineSessionRun): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.type !== 0) {
      obj.type = engineRunTypeToJSON(message.type);
    }
    if (message.status !== 0) {
      obj.status = engineRunStatusToJSON(message.status);
    }
    if (message.hasError !== false) {
      obj.hasError = message.hasError;
    }
    if (message.workerId !== "") {
      obj.workerId = message.workerId;
    }
    if (!message.createdAt.equals(Long.ZERO)) {
      obj.createdAt = (message.createdAt || Long.ZERO).toString();
    }
    if (!message.updatedAt.equals(Long.ZERO)) {
      obj.updatedAt = (message.updatedAt || Long.ZERO).toString();
    }
    if (!message.startedAt.equals(Long.ZERO)) {
      obj.startedAt = (message.startedAt || Long.ZERO).toString();
    }
    if (!message.endedAt.equals(Long.ZERO)) {
      obj.endedAt = (message.endedAt || Long.ZERO).toString();
    }
    if (!message.lastPingAt.equals(Long.ZERO)) {
      obj.lastPingAt = (message.lastPingAt || Long.ZERO).toString();
    }
    if (message.session !== undefined) {
      obj.session = EngineSession.toJSON(message.session);
    }
    return obj;
  },

  create(base?: DeepPartial<EngineSessionRun>): EngineSessionRun {
    return EngineSessionRun.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EngineSessionRun>): EngineSessionRun {
    const message = createBaseEngineSessionRun();
    message.id = object.id ?? "";
    message.sessionId = object.sessionId ?? "";
    message.type = object.type ?? 0;
    message.status = object.status ?? 0;
    message.hasError = object.hasError ?? false;
    message.workerId = object.workerId ?? "";
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Long.fromValue(object.createdAt)
      : Long.ZERO;
    message.updatedAt = (object.updatedAt !== undefined && object.updatedAt !== null)
      ? Long.fromValue(object.updatedAt)
      : Long.ZERO;
    message.startedAt = (object.startedAt !== undefined && object.startedAt !== null)
      ? Long.fromValue(object.startedAt)
      : Long.ZERO;
    message.endedAt = (object.endedAt !== undefined && object.endedAt !== null)
      ? Long.fromValue(object.endedAt)
      : Long.ZERO;
    message.lastPingAt = (object.lastPingAt !== undefined && object.lastPingAt !== null)
      ? Long.fromValue(object.lastPingAt)
      : Long.ZERO;
    message.session = (object.session !== undefined && object.session !== null)
      ? EngineSession.fromPartial(object.session)
      : undefined;
    return message;
  },
};

function createBaseEngineSessionError(): EngineSessionError {
  return {
    id: "",
    sessionId: "",
    runId: "",
    run: undefined,
    session: undefined,
    errorCode: "",
    errorMessage: "",
    mcpError: undefined,
    metadata: {},
    createdAt: Long.ZERO,
  };
}

export const EngineSessionError: MessageFns<EngineSessionError> = {
  encode(message: EngineSessionError, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.sessionId !== "") {
      writer.uint32(18).string(message.sessionId);
    }
    if (message.runId !== "") {
      writer.uint32(26).string(message.runId);
    }
    if (message.run !== undefined) {
      EngineSessionRun.encode(message.run, writer.uint32(34).fork()).join();
    }
    if (message.session !== undefined) {
      EngineSession.encode(message.session, writer.uint32(82).fork()).join();
    }
    if (message.errorCode !== "") {
      writer.uint32(42).string(message.errorCode);
    }
    if (message.errorMessage !== "") {
      writer.uint32(50).string(message.errorMessage);
    }
    if (message.mcpError !== undefined) {
      McpError.encode(message.mcpError, writer.uint32(58).fork()).join();
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      EngineSessionError_MetadataEntry.encode({ key: key as any, value }, writer.uint32(66).fork()).join();
    });
    if (!message.createdAt.equals(Long.ZERO)) {
      writer.uint32(72).int64(message.createdAt.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EngineSessionError {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEngineSessionError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.runId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.run = EngineSessionRun.decode(reader, reader.uint32());
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.session = EngineSession.decode(reader, reader.uint32());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.errorCode = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.mcpError = McpError.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          const entry8 = EngineSessionError_MetadataEntry.decode(reader, reader.uint32());
          if (entry8.value !== undefined) {
            message.metadata[entry8.key] = entry8.value;
          }
          continue;
        }
        case 9: {
          if (tag !== 72) {
            break;
          }

          message.createdAt = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EngineSessionError {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      runId: isSet(object.runId) ? globalThis.String(object.runId) : "",
      run: isSet(object.run) ? EngineSessionRun.fromJSON(object.run) : undefined,
      session: isSet(object.session) ? EngineSession.fromJSON(object.session) : undefined,
      errorCode: isSet(object.errorCode) ? globalThis.String(object.errorCode) : "",
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
      mcpError: isSet(object.mcpError) ? McpError.fromJSON(object.mcpError) : undefined,
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      createdAt: isSet(object.createdAt) ? Long.fromValue(object.createdAt) : Long.ZERO,
    };
  },

  toJSON(message: EngineSessionError): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.runId !== "") {
      obj.runId = message.runId;
    }
    if (message.run !== undefined) {
      obj.run = EngineSessionRun.toJSON(message.run);
    }
    if (message.session !== undefined) {
      obj.session = EngineSession.toJSON(message.session);
    }
    if (message.errorCode !== "") {
      obj.errorCode = message.errorCode;
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    if (message.mcpError !== undefined) {
      obj.mcpError = McpError.toJSON(message.mcpError);
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (!message.createdAt.equals(Long.ZERO)) {
      obj.createdAt = (message.createdAt || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<EngineSessionError>): EngineSessionError {
    return EngineSessionError.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EngineSessionError>): EngineSessionError {
    const message = createBaseEngineSessionError();
    message.id = object.id ?? "";
    message.sessionId = object.sessionId ?? "";
    message.runId = object.runId ?? "";
    message.run = (object.run !== undefined && object.run !== null)
      ? EngineSessionRun.fromPartial(object.run)
      : undefined;
    message.session = (object.session !== undefined && object.session !== null)
      ? EngineSession.fromPartial(object.session)
      : undefined;
    message.errorCode = object.errorCode ?? "";
    message.errorMessage = object.errorMessage ?? "";
    message.mcpError = (object.mcpError !== undefined && object.mcpError !== null)
      ? McpError.fromPartial(object.mcpError)
      : undefined;
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Long.fromValue(object.createdAt)
      : Long.ZERO;
    return message;
  },
};

function createBaseEngineSessionError_MetadataEntry(): EngineSessionError_MetadataEntry {
  return { key: "", value: "" };
}

export const EngineSessionError_MetadataEntry: MessageFns<EngineSessionError_MetadataEntry> = {
  encode(message: EngineSessionError_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EngineSessionError_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEngineSessionError_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EngineSessionError_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: EngineSessionError_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<EngineSessionError_MetadataEntry>): EngineSessionError_MetadataEntry {
    return EngineSessionError_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EngineSessionError_MetadataEntry>): EngineSessionError_MetadataEntry {
    const message = createBaseEngineSessionError_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseEngineSessionEvent(): EngineSessionEvent {
  return {
    id: "",
    sessionId: "",
    runId: "",
    errorId: "",
    type: 0,
    run: undefined,
    session: undefined,
    error: undefined,
    metadata: {},
    mcpOutput: undefined,
    createdAt: Long.ZERO,
  };
}

export const EngineSessionEvent: MessageFns<EngineSessionEvent> = {
  encode(message: EngineSessionEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.sessionId !== "") {
      writer.uint32(18).string(message.sessionId);
    }
    if (message.runId !== "") {
      writer.uint32(26).string(message.runId);
    }
    if (message.errorId !== "") {
      writer.uint32(34).string(message.errorId);
    }
    if (message.type !== 0) {
      writer.uint32(40).int32(message.type);
    }
    if (message.run !== undefined) {
      EngineSessionRun.encode(message.run, writer.uint32(50).fork()).join();
    }
    if (message.session !== undefined) {
      EngineSession.encode(message.session, writer.uint32(58).fork()).join();
    }
    if (message.error !== undefined) {
      EngineSessionError.encode(message.error, writer.uint32(66).fork()).join();
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      EngineSessionEvent_MetadataEntry.encode({ key: key as any, value }, writer.uint32(90).fork()).join();
    });
    if (message.mcpOutput !== undefined) {
      McpOutput.encode(message.mcpOutput, writer.uint32(82).fork()).join();
    }
    if (!message.createdAt.equals(Long.ZERO)) {
      writer.uint32(96).int64(message.createdAt.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EngineSessionEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEngineSessionEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.runId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.errorId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.run = EngineSessionRun.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.session = EngineSession.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.error = EngineSessionError.decode(reader, reader.uint32());
          continue;
        }
        case 11: {
          if (tag !== 90) {
            break;
          }

          const entry11 = EngineSessionEvent_MetadataEntry.decode(reader, reader.uint32());
          if (entry11.value !== undefined) {
            message.metadata[entry11.key] = entry11.value;
          }
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.mcpOutput = McpOutput.decode(reader, reader.uint32());
          continue;
        }
        case 12: {
          if (tag !== 96) {
            break;
          }

          message.createdAt = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EngineSessionEvent {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      runId: isSet(object.runId) ? globalThis.String(object.runId) : "",
      errorId: isSet(object.errorId) ? globalThis.String(object.errorId) : "",
      type: isSet(object.type) ? engineSessionEventTypeFromJSON(object.type) : 0,
      run: isSet(object.run) ? EngineSessionRun.fromJSON(object.run) : undefined,
      session: isSet(object.session) ? EngineSession.fromJSON(object.session) : undefined,
      error: isSet(object.error) ? EngineSessionError.fromJSON(object.error) : undefined,
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      mcpOutput: isSet(object.mcpOutput) ? McpOutput.fromJSON(object.mcpOutput) : undefined,
      createdAt: isSet(object.createdAt) ? Long.fromValue(object.createdAt) : Long.ZERO,
    };
  },

  toJSON(message: EngineSessionEvent): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.runId !== "") {
      obj.runId = message.runId;
    }
    if (message.errorId !== "") {
      obj.errorId = message.errorId;
    }
    if (message.type !== 0) {
      obj.type = engineSessionEventTypeToJSON(message.type);
    }
    if (message.run !== undefined) {
      obj.run = EngineSessionRun.toJSON(message.run);
    }
    if (message.session !== undefined) {
      obj.session = EngineSession.toJSON(message.session);
    }
    if (message.error !== undefined) {
      obj.error = EngineSessionError.toJSON(message.error);
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.mcpOutput !== undefined) {
      obj.mcpOutput = McpOutput.toJSON(message.mcpOutput);
    }
    if (!message.createdAt.equals(Long.ZERO)) {
      obj.createdAt = (message.createdAt || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<EngineSessionEvent>): EngineSessionEvent {
    return EngineSessionEvent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EngineSessionEvent>): EngineSessionEvent {
    const message = createBaseEngineSessionEvent();
    message.id = object.id ?? "";
    message.sessionId = object.sessionId ?? "";
    message.runId = object.runId ?? "";
    message.errorId = object.errorId ?? "";
    message.type = object.type ?? 0;
    message.run = (object.run !== undefined && object.run !== null)
      ? EngineSessionRun.fromPartial(object.run)
      : undefined;
    message.session = (object.session !== undefined && object.session !== null)
      ? EngineSession.fromPartial(object.session)
      : undefined;
    message.error = (object.error !== undefined && object.error !== null)
      ? EngineSessionError.fromPartial(object.error)
      : undefined;
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.mcpOutput = (object.mcpOutput !== undefined && object.mcpOutput !== null)
      ? McpOutput.fromPartial(object.mcpOutput)
      : undefined;
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Long.fromValue(object.createdAt)
      : Long.ZERO;
    return message;
  },
};

function createBaseEngineSessionEvent_MetadataEntry(): EngineSessionEvent_MetadataEntry {
  return { key: "", value: "" };
}

export const EngineSessionEvent_MetadataEntry: MessageFns<EngineSessionEvent_MetadataEntry> = {
  encode(message: EngineSessionEvent_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EngineSessionEvent_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEngineSessionEvent_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EngineSessionEvent_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: EngineSessionEvent_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<EngineSessionEvent_MetadataEntry>): EngineSessionEvent_MetadataEntry {
    return EngineSessionEvent_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EngineSessionEvent_MetadataEntry>): EngineSessionEvent_MetadataEntry {
    const message = createBaseEngineSessionEvent_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseEngineSessionMessage(): EngineSessionMessage {
  return {
    id: "",
    index: 0,
    sender: 0,
    sessionId: "",
    runId: "",
    run: undefined,
    session: undefined,
    mcpMessage: undefined,
    metadata: {},
    createdAt: Long.ZERO,
  };
}

export const EngineSessionMessage: MessageFns<EngineSessionMessage> = {
  encode(message: EngineSessionMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.index !== 0) {
      writer.uint32(16).int32(message.index);
    }
    if (message.sender !== 0) {
      writer.uint32(24).int32(message.sender);
    }
    if (message.sessionId !== "") {
      writer.uint32(34).string(message.sessionId);
    }
    if (message.runId !== "") {
      writer.uint32(42).string(message.runId);
    }
    if (message.run !== undefined) {
      EngineSessionRun.encode(message.run, writer.uint32(50).fork()).join();
    }
    if (message.session !== undefined) {
      EngineSession.encode(message.session, writer.uint32(58).fork()).join();
    }
    if (message.mcpMessage !== undefined) {
      McpMessage.encode(message.mcpMessage, writer.uint32(66).fork()).join();
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      EngineSessionMessage_MetadataEntry.encode({ key: key as any, value }, writer.uint32(74).fork()).join();
    });
    if (!message.createdAt.equals(Long.ZERO)) {
      writer.uint32(80).int64(message.createdAt.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EngineSessionMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEngineSessionMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.index = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.sender = reader.int32() as any;
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.runId = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.run = EngineSessionRun.decode(reader, reader.uint32());
          continue;
        }
        case 7: {
          if (tag !== 58) {
            break;
          }

          message.session = EngineSession.decode(reader, reader.uint32());
          continue;
        }
        case 8: {
          if (tag !== 66) {
            break;
          }

          message.mcpMessage = McpMessage.decode(reader, reader.uint32());
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          const entry9 = EngineSessionMessage_MetadataEntry.decode(reader, reader.uint32());
          if (entry9.value !== undefined) {
            message.metadata[entry9.key] = entry9.value;
          }
          continue;
        }
        case 10: {
          if (tag !== 80) {
            break;
          }

          message.createdAt = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EngineSessionMessage {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      index: isSet(object.index) ? globalThis.Number(object.index) : 0,
      sender: isSet(object.sender) ? sessionMessageSenderFromJSON(object.sender) : 0,
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      runId: isSet(object.runId) ? globalThis.String(object.runId) : "",
      run: isSet(object.run) ? EngineSessionRun.fromJSON(object.run) : undefined,
      session: isSet(object.session) ? EngineSession.fromJSON(object.session) : undefined,
      mcpMessage: isSet(object.mcpMessage) ? McpMessage.fromJSON(object.mcpMessage) : undefined,
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      createdAt: isSet(object.createdAt) ? Long.fromValue(object.createdAt) : Long.ZERO,
    };
  },

  toJSON(message: EngineSessionMessage): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.index !== 0) {
      obj.index = Math.round(message.index);
    }
    if (message.sender !== 0) {
      obj.sender = sessionMessageSenderToJSON(message.sender);
    }
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.runId !== "") {
      obj.runId = message.runId;
    }
    if (message.run !== undefined) {
      obj.run = EngineSessionRun.toJSON(message.run);
    }
    if (message.session !== undefined) {
      obj.session = EngineSession.toJSON(message.session);
    }
    if (message.mcpMessage !== undefined) {
      obj.mcpMessage = McpMessage.toJSON(message.mcpMessage);
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (!message.createdAt.equals(Long.ZERO)) {
      obj.createdAt = (message.createdAt || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<EngineSessionMessage>): EngineSessionMessage {
    return EngineSessionMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EngineSessionMessage>): EngineSessionMessage {
    const message = createBaseEngineSessionMessage();
    message.id = object.id ?? "";
    message.index = object.index ?? 0;
    message.sender = object.sender ?? 0;
    message.sessionId = object.sessionId ?? "";
    message.runId = object.runId ?? "";
    message.run = (object.run !== undefined && object.run !== null)
      ? EngineSessionRun.fromPartial(object.run)
      : undefined;
    message.session = (object.session !== undefined && object.session !== null)
      ? EngineSession.fromPartial(object.session)
      : undefined;
    message.mcpMessage = (object.mcpMessage !== undefined && object.mcpMessage !== null)
      ? McpMessage.fromPartial(object.mcpMessage)
      : undefined;
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.createdAt = (object.createdAt !== undefined && object.createdAt !== null)
      ? Long.fromValue(object.createdAt)
      : Long.ZERO;
    return message;
  },
};

function createBaseEngineSessionMessage_MetadataEntry(): EngineSessionMessage_MetadataEntry {
  return { key: "", value: "" };
}

export const EngineSessionMessage_MetadataEntry: MessageFns<EngineSessionMessage_MetadataEntry> = {
  encode(message: EngineSessionMessage_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EngineSessionMessage_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEngineSessionMessage_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EngineSessionMessage_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: EngineSessionMessage_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<EngineSessionMessage_MetadataEntry>): EngineSessionMessage_MetadataEntry {
    return EngineSessionMessage_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<EngineSessionMessage_MetadataEntry>): EngineSessionMessage_MetadataEntry {
    const message = createBaseEngineSessionMessage_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseListPagination(): ListPagination {
  return { afterId: "", beforeId: "", limit: 0, order: 0 };
}

export const ListPagination: MessageFns<ListPagination> = {
  encode(message: ListPagination, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.afterId !== "") {
      writer.uint32(10).string(message.afterId);
    }
    if (message.beforeId !== "") {
      writer.uint32(18).string(message.beforeId);
    }
    if (message.limit !== 0) {
      writer.uint32(24).int32(message.limit);
    }
    if (message.order !== 0) {
      writer.uint32(32).int32(message.order);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPagination {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPagination();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.afterId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.beforeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.order = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPagination {
    return {
      afterId: isSet(object.afterId) ? globalThis.String(object.afterId) : "",
      beforeId: isSet(object.beforeId) ? globalThis.String(object.beforeId) : "",
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      order: isSet(object.order) ? listPaginationOrderFromJSON(object.order) : 0,
    };
  },

  toJSON(message: ListPagination): unknown {
    const obj: any = {};
    if (message.afterId !== "") {
      obj.afterId = message.afterId;
    }
    if (message.beforeId !== "") {
      obj.beforeId = message.beforeId;
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.order !== 0) {
      obj.order = listPaginationOrderToJSON(message.order);
    }
    return obj;
  },

  create(base?: DeepPartial<ListPagination>): ListPagination {
    return ListPagination.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListPagination>): ListPagination {
    const message = createBaseListPagination();
    message.afterId = object.afterId ?? "";
    message.beforeId = object.beforeId ?? "";
    message.limit = object.limit ?? 0;
    message.order = object.order ?? 0;
    return message;
  },
};

function createBaseListSessionsRequest(): ListSessionsRequest {
  return { externalId: "", pagination: undefined };
}

export const ListSessionsRequest: MessageFns<ListSessionsRequest> = {
  encode(message: ListSessionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.externalId !== "") {
      writer.uint32(10).string(message.externalId);
    }
    if (message.pagination !== undefined) {
      ListPagination.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSessionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSessionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.externalId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = ListPagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSessionsRequest {
    return {
      externalId: isSet(object.externalId) ? globalThis.String(object.externalId) : "",
      pagination: isSet(object.pagination) ? ListPagination.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListSessionsRequest): unknown {
    const obj: any = {};
    if (message.externalId !== "") {
      obj.externalId = message.externalId;
    }
    if (message.pagination !== undefined) {
      obj.pagination = ListPagination.toJSON(message.pagination);
    }
    return obj;
  },

  create(base?: DeepPartial<ListSessionsRequest>): ListSessionsRequest {
    return ListSessionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSessionsRequest>): ListSessionsRequest {
    const message = createBaseListSessionsRequest();
    message.externalId = object.externalId ?? "";
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? ListPagination.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseListSessionsResponse(): ListSessionsResponse {
  return { sessions: [] };
}

export const ListSessionsResponse: MessageFns<ListSessionsResponse> = {
  encode(message: ListSessionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.sessions) {
      EngineSession.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSessionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSessionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessions.push(EngineSession.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSessionsResponse {
    return {
      sessions: globalThis.Array.isArray(object?.sessions)
        ? object.sessions.map((e: any) => EngineSession.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListSessionsResponse): unknown {
    const obj: any = {};
    if (message.sessions?.length) {
      obj.sessions = message.sessions.map((e) => EngineSession.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ListSessionsResponse>): ListSessionsResponse {
    return ListSessionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSessionsResponse>): ListSessionsResponse {
    const message = createBaseListSessionsResponse();
    message.sessions = object.sessions?.map((e) => EngineSession.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetSessionRequest(): GetSessionRequest {
  return { sessionId: "" };
}

export const GetSessionRequest: MessageFns<GetSessionRequest> = {
  encode(message: GetSessionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSessionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSessionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSessionRequest {
    return { sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "" };
  },

  toJSON(message: GetSessionRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetSessionRequest>): GetSessionRequest {
    return GetSessionRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetSessionRequest>): GetSessionRequest {
    const message = createBaseGetSessionRequest();
    message.sessionId = object.sessionId ?? "";
    return message;
  },
};

function createBaseGetSessionResponse(): GetSessionResponse {
  return { session: undefined };
}

export const GetSessionResponse: MessageFns<GetSessionResponse> = {
  encode(message: GetSessionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.session !== undefined) {
      EngineSession.encode(message.session, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetSessionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetSessionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.session = EngineSession.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetSessionResponse {
    return { session: isSet(object.session) ? EngineSession.fromJSON(object.session) : undefined };
  },

  toJSON(message: GetSessionResponse): unknown {
    const obj: any = {};
    if (message.session !== undefined) {
      obj.session = EngineSession.toJSON(message.session);
    }
    return obj;
  },

  create(base?: DeepPartial<GetSessionResponse>): GetSessionResponse {
    return GetSessionResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetSessionResponse>): GetSessionResponse {
    const message = createBaseGetSessionResponse();
    message.session = (object.session !== undefined && object.session !== null)
      ? EngineSession.fromPartial(object.session)
      : undefined;
    return message;
  },
};

function createBaseListRunsRequest(): ListRunsRequest {
  return { sessionId: "", pagination: undefined };
}

export const ListRunsRequest: MessageFns<ListRunsRequest> = {
  encode(message: ListRunsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.pagination !== undefined) {
      ListPagination.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRunsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRunsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = ListPagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRunsRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      pagination: isSet(object.pagination) ? ListPagination.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListRunsRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.pagination !== undefined) {
      obj.pagination = ListPagination.toJSON(message.pagination);
    }
    return obj;
  },

  create(base?: DeepPartial<ListRunsRequest>): ListRunsRequest {
    return ListRunsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListRunsRequest>): ListRunsRequest {
    const message = createBaseListRunsRequest();
    message.sessionId = object.sessionId ?? "";
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? ListPagination.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseListRunsResponse(): ListRunsResponse {
  return { runs: [] };
}

export const ListRunsResponse: MessageFns<ListRunsResponse> = {
  encode(message: ListRunsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.runs) {
      EngineSessionRun.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRunsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRunsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.runs.push(EngineSessionRun.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRunsResponse {
    return {
      runs: globalThis.Array.isArray(object?.runs) ? object.runs.map((e: any) => EngineSessionRun.fromJSON(e)) : [],
    };
  },

  toJSON(message: ListRunsResponse): unknown {
    const obj: any = {};
    if (message.runs?.length) {
      obj.runs = message.runs.map((e) => EngineSessionRun.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ListRunsResponse>): ListRunsResponse {
    return ListRunsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListRunsResponse>): ListRunsResponse {
    const message = createBaseListRunsResponse();
    message.runs = object.runs?.map((e) => EngineSessionRun.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetRunRequest(): GetRunRequest {
  return { runId: "" };
}

export const GetRunRequest: MessageFns<GetRunRequest> = {
  encode(message: GetRunRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.runId !== "") {
      writer.uint32(10).string(message.runId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRunRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRunRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.runId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRunRequest {
    return { runId: isSet(object.runId) ? globalThis.String(object.runId) : "" };
  },

  toJSON(message: GetRunRequest): unknown {
    const obj: any = {};
    if (message.runId !== "") {
      obj.runId = message.runId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetRunRequest>): GetRunRequest {
    return GetRunRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetRunRequest>): GetRunRequest {
    const message = createBaseGetRunRequest();
    message.runId = object.runId ?? "";
    return message;
  },
};

function createBaseGetRunResponse(): GetRunResponse {
  return { run: undefined };
}

export const GetRunResponse: MessageFns<GetRunResponse> = {
  encode(message: GetRunResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.run !== undefined) {
      EngineSessionRun.encode(message.run, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetRunResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetRunResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.run = EngineSessionRun.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetRunResponse {
    return { run: isSet(object.run) ? EngineSessionRun.fromJSON(object.run) : undefined };
  },

  toJSON(message: GetRunResponse): unknown {
    const obj: any = {};
    if (message.run !== undefined) {
      obj.run = EngineSessionRun.toJSON(message.run);
    }
    return obj;
  },

  create(base?: DeepPartial<GetRunResponse>): GetRunResponse {
    return GetRunResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetRunResponse>): GetRunResponse {
    const message = createBaseGetRunResponse();
    message.run = (object.run !== undefined && object.run !== null)
      ? EngineSessionRun.fromPartial(object.run)
      : undefined;
    return message;
  },
};

function createBaseGetErrorRequest(): GetErrorRequest {
  return { errorId: "" };
}

export const GetErrorRequest: MessageFns<GetErrorRequest> = {
  encode(message: GetErrorRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.errorId !== "") {
      writer.uint32(18).string(message.errorId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetErrorRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetErrorRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errorId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetErrorRequest {
    return { errorId: isSet(object.errorId) ? globalThis.String(object.errorId) : "" };
  },

  toJSON(message: GetErrorRequest): unknown {
    const obj: any = {};
    if (message.errorId !== "") {
      obj.errorId = message.errorId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetErrorRequest>): GetErrorRequest {
    return GetErrorRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetErrorRequest>): GetErrorRequest {
    const message = createBaseGetErrorRequest();
    message.errorId = object.errorId ?? "";
    return message;
  },
};

function createBaseGetErrorResponse(): GetErrorResponse {
  return { error: undefined };
}

export const GetErrorResponse: MessageFns<GetErrorResponse> = {
  encode(message: GetErrorResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.error !== undefined) {
      EngineSessionError.encode(message.error, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetErrorResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetErrorResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.error = EngineSessionError.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetErrorResponse {
    return { error: isSet(object.error) ? EngineSessionError.fromJSON(object.error) : undefined };
  },

  toJSON(message: GetErrorResponse): unknown {
    const obj: any = {};
    if (message.error !== undefined) {
      obj.error = EngineSessionError.toJSON(message.error);
    }
    return obj;
  },

  create(base?: DeepPartial<GetErrorResponse>): GetErrorResponse {
    return GetErrorResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetErrorResponse>): GetErrorResponse {
    const message = createBaseGetErrorResponse();
    message.error = (object.error !== undefined && object.error !== null)
      ? EngineSessionError.fromPartial(object.error)
      : undefined;
    return message;
  },
};

function createBaseGetEventRequest(): GetEventRequest {
  return { eventId: "" };
}

export const GetEventRequest: MessageFns<GetEventRequest> = {
  encode(message: GetEventRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.eventId !== "") {
      writer.uint32(10).string(message.eventId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetEventRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetEventRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.eventId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetEventRequest {
    return { eventId: isSet(object.eventId) ? globalThis.String(object.eventId) : "" };
  },

  toJSON(message: GetEventRequest): unknown {
    const obj: any = {};
    if (message.eventId !== "") {
      obj.eventId = message.eventId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetEventRequest>): GetEventRequest {
    return GetEventRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetEventRequest>): GetEventRequest {
    const message = createBaseGetEventRequest();
    message.eventId = object.eventId ?? "";
    return message;
  },
};

function createBaseGetEventResponse(): GetEventResponse {
  return { event: undefined };
}

export const GetEventResponse: MessageFns<GetEventResponse> = {
  encode(message: GetEventResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.event !== undefined) {
      EngineSessionEvent.encode(message.event, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetEventResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetEventResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.event = EngineSessionEvent.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetEventResponse {
    return { event: isSet(object.event) ? EngineSessionEvent.fromJSON(object.event) : undefined };
  },

  toJSON(message: GetEventResponse): unknown {
    const obj: any = {};
    if (message.event !== undefined) {
      obj.event = EngineSessionEvent.toJSON(message.event);
    }
    return obj;
  },

  create(base?: DeepPartial<GetEventResponse>): GetEventResponse {
    return GetEventResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetEventResponse>): GetEventResponse {
    const message = createBaseGetEventResponse();
    message.event = (object.event !== undefined && object.event !== null)
      ? EngineSessionEvent.fromPartial(object.event)
      : undefined;
    return message;
  },
};

function createBaseGetMessageRequest(): GetMessageRequest {
  return { messageId: "" };
}

export const GetMessageRequest: MessageFns<GetMessageRequest> = {
  encode(message: GetMessageRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.messageId !== "") {
      writer.uint32(10).string(message.messageId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetMessageRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMessageRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.messageId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetMessageRequest {
    return { messageId: isSet(object.messageId) ? globalThis.String(object.messageId) : "" };
  },

  toJSON(message: GetMessageRequest): unknown {
    const obj: any = {};
    if (message.messageId !== "") {
      obj.messageId = message.messageId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetMessageRequest>): GetMessageRequest {
    return GetMessageRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetMessageRequest>): GetMessageRequest {
    const message = createBaseGetMessageRequest();
    message.messageId = object.messageId ?? "";
    return message;
  },
};

function createBaseGetMessageResponse(): GetMessageResponse {
  return { message: undefined };
}

export const GetMessageResponse: MessageFns<GetMessageResponse> = {
  encode(message: GetMessageResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== undefined) {
      EngineSessionMessage.encode(message.message, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetMessageResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetMessageResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = EngineSessionMessage.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetMessageResponse {
    return { message: isSet(object.message) ? EngineSessionMessage.fromJSON(object.message) : undefined };
  },

  toJSON(message: GetMessageResponse): unknown {
    const obj: any = {};
    if (message.message !== undefined) {
      obj.message = EngineSessionMessage.toJSON(message.message);
    }
    return obj;
  },

  create(base?: DeepPartial<GetMessageResponse>): GetMessageResponse {
    return GetMessageResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetMessageResponse>): GetMessageResponse {
    const message = createBaseGetMessageResponse();
    message.message = (object.message !== undefined && object.message !== null)
      ? EngineSessionMessage.fromPartial(object.message)
      : undefined;
    return message;
  },
};

function createBaseListRunErrorsRequest(): ListRunErrorsRequest {
  return { runId: "", pagination: undefined };
}

export const ListRunErrorsRequest: MessageFns<ListRunErrorsRequest> = {
  encode(message: ListRunErrorsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.runId !== "") {
      writer.uint32(10).string(message.runId);
    }
    if (message.pagination !== undefined) {
      ListPagination.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRunErrorsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRunErrorsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.runId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = ListPagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRunErrorsRequest {
    return {
      runId: isSet(object.runId) ? globalThis.String(object.runId) : "",
      pagination: isSet(object.pagination) ? ListPagination.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListRunErrorsRequest): unknown {
    const obj: any = {};
    if (message.runId !== "") {
      obj.runId = message.runId;
    }
    if (message.pagination !== undefined) {
      obj.pagination = ListPagination.toJSON(message.pagination);
    }
    return obj;
  },

  create(base?: DeepPartial<ListRunErrorsRequest>): ListRunErrorsRequest {
    return ListRunErrorsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListRunErrorsRequest>): ListRunErrorsRequest {
    const message = createBaseListRunErrorsRequest();
    message.runId = object.runId ?? "";
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? ListPagination.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseListRunErrorsResponse(): ListRunErrorsResponse {
  return { errors: [] };
}

export const ListRunErrorsResponse: MessageFns<ListRunErrorsResponse> = {
  encode(message: ListRunErrorsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.errors) {
      EngineSessionError.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRunErrorsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRunErrorsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.errors.push(EngineSessionError.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRunErrorsResponse {
    return {
      errors: globalThis.Array.isArray(object?.errors)
        ? object.errors.map((e: any) => EngineSessionError.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListRunErrorsResponse): unknown {
    const obj: any = {};
    if (message.errors?.length) {
      obj.errors = message.errors.map((e) => EngineSessionError.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ListRunErrorsResponse>): ListRunErrorsResponse {
    return ListRunErrorsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListRunErrorsResponse>): ListRunErrorsResponse {
    const message = createBaseListRunErrorsResponse();
    message.errors = object.errors?.map((e) => EngineSessionError.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListRunEventsRequest(): ListRunEventsRequest {
  return { runId: "", pagination: undefined };
}

export const ListRunEventsRequest: MessageFns<ListRunEventsRequest> = {
  encode(message: ListRunEventsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.runId !== "") {
      writer.uint32(10).string(message.runId);
    }
    if (message.pagination !== undefined) {
      ListPagination.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRunEventsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRunEventsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.runId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = ListPagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRunEventsRequest {
    return {
      runId: isSet(object.runId) ? globalThis.String(object.runId) : "",
      pagination: isSet(object.pagination) ? ListPagination.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListRunEventsRequest): unknown {
    const obj: any = {};
    if (message.runId !== "") {
      obj.runId = message.runId;
    }
    if (message.pagination !== undefined) {
      obj.pagination = ListPagination.toJSON(message.pagination);
    }
    return obj;
  },

  create(base?: DeepPartial<ListRunEventsRequest>): ListRunEventsRequest {
    return ListRunEventsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListRunEventsRequest>): ListRunEventsRequest {
    const message = createBaseListRunEventsRequest();
    message.runId = object.runId ?? "";
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? ListPagination.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseListRunEventsResponse(): ListRunEventsResponse {
  return { events: [] };
}

export const ListRunEventsResponse: MessageFns<ListRunEventsResponse> = {
  encode(message: ListRunEventsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.events) {
      EngineSessionEvent.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRunEventsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRunEventsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.events.push(EngineSessionEvent.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRunEventsResponse {
    return {
      events: globalThis.Array.isArray(object?.events)
        ? object.events.map((e: any) => EngineSessionEvent.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListRunEventsResponse): unknown {
    const obj: any = {};
    if (message.events?.length) {
      obj.events = message.events.map((e) => EngineSessionEvent.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ListRunEventsResponse>): ListRunEventsResponse {
    return ListRunEventsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListRunEventsResponse>): ListRunEventsResponse {
    const message = createBaseListRunEventsResponse();
    message.events = object.events?.map((e) => EngineSessionEvent.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListRunMessagesRequest(): ListRunMessagesRequest {
  return { runId: "", pagination: undefined };
}

export const ListRunMessagesRequest: MessageFns<ListRunMessagesRequest> = {
  encode(message: ListRunMessagesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.runId !== "") {
      writer.uint32(10).string(message.runId);
    }
    if (message.pagination !== undefined) {
      ListPagination.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRunMessagesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRunMessagesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.runId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = ListPagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRunMessagesRequest {
    return {
      runId: isSet(object.runId) ? globalThis.String(object.runId) : "",
      pagination: isSet(object.pagination) ? ListPagination.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListRunMessagesRequest): unknown {
    const obj: any = {};
    if (message.runId !== "") {
      obj.runId = message.runId;
    }
    if (message.pagination !== undefined) {
      obj.pagination = ListPagination.toJSON(message.pagination);
    }
    return obj;
  },

  create(base?: DeepPartial<ListRunMessagesRequest>): ListRunMessagesRequest {
    return ListRunMessagesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListRunMessagesRequest>): ListRunMessagesRequest {
    const message = createBaseListRunMessagesRequest();
    message.runId = object.runId ?? "";
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? ListPagination.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseListRunMessagesResponse(): ListRunMessagesResponse {
  return { messages: [] };
}

export const ListRunMessagesResponse: MessageFns<ListRunMessagesResponse> = {
  encode(message: ListRunMessagesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.messages) {
      EngineSessionMessage.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRunMessagesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRunMessagesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.messages.push(EngineSessionMessage.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRunMessagesResponse {
    return {
      messages: globalThis.Array.isArray(object?.messages)
        ? object.messages.map((e: any) => EngineSessionMessage.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListRunMessagesResponse): unknown {
    const obj: any = {};
    if (message.messages?.length) {
      obj.messages = message.messages.map((e) => EngineSessionMessage.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ListRunMessagesResponse>): ListRunMessagesResponse {
    return ListRunMessagesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListRunMessagesResponse>): ListRunMessagesResponse {
    const message = createBaseListRunMessagesResponse();
    message.messages = object.messages?.map((e) => EngineSessionMessage.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListSessionEventsRequest(): ListSessionEventsRequest {
  return { sessionId: "", pagination: undefined };
}

export const ListSessionEventsRequest: MessageFns<ListSessionEventsRequest> = {
  encode(message: ListSessionEventsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.pagination !== undefined) {
      ListPagination.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSessionEventsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSessionEventsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = ListPagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSessionEventsRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      pagination: isSet(object.pagination) ? ListPagination.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListSessionEventsRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.pagination !== undefined) {
      obj.pagination = ListPagination.toJSON(message.pagination);
    }
    return obj;
  },

  create(base?: DeepPartial<ListSessionEventsRequest>): ListSessionEventsRequest {
    return ListSessionEventsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSessionEventsRequest>): ListSessionEventsRequest {
    const message = createBaseListSessionEventsRequest();
    message.sessionId = object.sessionId ?? "";
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? ListPagination.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseListSessionEventsResponse(): ListSessionEventsResponse {
  return { events: [] };
}

export const ListSessionEventsResponse: MessageFns<ListSessionEventsResponse> = {
  encode(message: ListSessionEventsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.events) {
      EngineSessionEvent.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSessionEventsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSessionEventsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.events.push(EngineSessionEvent.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSessionEventsResponse {
    return {
      events: globalThis.Array.isArray(object?.events)
        ? object.events.map((e: any) => EngineSessionEvent.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListSessionEventsResponse): unknown {
    const obj: any = {};
    if (message.events?.length) {
      obj.events = message.events.map((e) => EngineSessionEvent.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ListSessionEventsResponse>): ListSessionEventsResponse {
    return ListSessionEventsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSessionEventsResponse>): ListSessionEventsResponse {
    const message = createBaseListSessionEventsResponse();
    message.events = object.events?.map((e) => EngineSessionEvent.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListSessionErrorsRequest(): ListSessionErrorsRequest {
  return { sessionId: "", pagination: undefined };
}

export const ListSessionErrorsRequest: MessageFns<ListSessionErrorsRequest> = {
  encode(message: ListSessionErrorsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.pagination !== undefined) {
      ListPagination.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSessionErrorsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSessionErrorsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = ListPagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSessionErrorsRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      pagination: isSet(object.pagination) ? ListPagination.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListSessionErrorsRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.pagination !== undefined) {
      obj.pagination = ListPagination.toJSON(message.pagination);
    }
    return obj;
  },

  create(base?: DeepPartial<ListSessionErrorsRequest>): ListSessionErrorsRequest {
    return ListSessionErrorsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSessionErrorsRequest>): ListSessionErrorsRequest {
    const message = createBaseListSessionErrorsRequest();
    message.sessionId = object.sessionId ?? "";
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? ListPagination.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseListSessionErrorsResponse(): ListSessionErrorsResponse {
  return { errors: [] };
}

export const ListSessionErrorsResponse: MessageFns<ListSessionErrorsResponse> = {
  encode(message: ListSessionErrorsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.errors) {
      EngineSessionError.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSessionErrorsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSessionErrorsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.errors.push(EngineSessionError.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSessionErrorsResponse {
    return {
      errors: globalThis.Array.isArray(object?.errors)
        ? object.errors.map((e: any) => EngineSessionError.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListSessionErrorsResponse): unknown {
    const obj: any = {};
    if (message.errors?.length) {
      obj.errors = message.errors.map((e) => EngineSessionError.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ListSessionErrorsResponse>): ListSessionErrorsResponse {
    return ListSessionErrorsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSessionErrorsResponse>): ListSessionErrorsResponse {
    const message = createBaseListSessionErrorsResponse();
    message.errors = object.errors?.map((e) => EngineSessionError.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListSessionMessagesRequest(): ListSessionMessagesRequest {
  return { sessionId: "", pagination: undefined };
}

export const ListSessionMessagesRequest: MessageFns<ListSessionMessagesRequest> = {
  encode(message: ListSessionMessagesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sessionId !== "") {
      writer.uint32(10).string(message.sessionId);
    }
    if (message.pagination !== undefined) {
      ListPagination.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSessionMessagesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSessionMessagesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = ListPagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSessionMessagesRequest {
    return {
      sessionId: isSet(object.sessionId) ? globalThis.String(object.sessionId) : "",
      pagination: isSet(object.pagination) ? ListPagination.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListSessionMessagesRequest): unknown {
    const obj: any = {};
    if (message.sessionId !== "") {
      obj.sessionId = message.sessionId;
    }
    if (message.pagination !== undefined) {
      obj.pagination = ListPagination.toJSON(message.pagination);
    }
    return obj;
  },

  create(base?: DeepPartial<ListSessionMessagesRequest>): ListSessionMessagesRequest {
    return ListSessionMessagesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSessionMessagesRequest>): ListSessionMessagesRequest {
    const message = createBaseListSessionMessagesRequest();
    message.sessionId = object.sessionId ?? "";
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? ListPagination.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseListSessionMessagesResponse(): ListSessionMessagesResponse {
  return { messages: [] };
}

export const ListSessionMessagesResponse: MessageFns<ListSessionMessagesResponse> = {
  encode(message: ListSessionMessagesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.messages) {
      EngineSessionMessage.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListSessionMessagesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListSessionMessagesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.messages.push(EngineSessionMessage.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListSessionMessagesResponse {
    return {
      messages: globalThis.Array.isArray(object?.messages)
        ? object.messages.map((e: any) => EngineSessionMessage.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ListSessionMessagesResponse): unknown {
    const obj: any = {};
    if (message.messages?.length) {
      obj.messages = message.messages.map((e) => EngineSessionMessage.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<ListSessionMessagesResponse>): ListSessionMessagesResponse {
    return ListSessionMessagesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListSessionMessagesResponse>): ListSessionMessagesResponse {
    const message = createBaseListSessionMessagesResponse();
    message.messages = object.messages?.map((e) => EngineSessionMessage.fromPartial(e)) || [];
    return message;
  },
};

function createBaseListRecentlyActiveRunsRequest(): ListRecentlyActiveRunsRequest {
  return { since: Long.ZERO };
}

export const ListRecentlyActiveRunsRequest: MessageFns<ListRecentlyActiveRunsRequest> = {
  encode(message: ListRecentlyActiveRunsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.since.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.since.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRecentlyActiveRunsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRecentlyActiveRunsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.since = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRecentlyActiveRunsRequest {
    return { since: isSet(object.since) ? Long.fromValue(object.since) : Long.ZERO };
  },

  toJSON(message: ListRecentlyActiveRunsRequest): unknown {
    const obj: any = {};
    if (!message.since.equals(Long.ZERO)) {
      obj.since = (message.since || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<ListRecentlyActiveRunsRequest>): ListRecentlyActiveRunsRequest {
    return ListRecentlyActiveRunsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListRecentlyActiveRunsRequest>): ListRecentlyActiveRunsRequest {
    const message = createBaseListRecentlyActiveRunsRequest();
    message.since = (object.since !== undefined && object.since !== null) ? Long.fromValue(object.since) : Long.ZERO;
    return message;
  },
};

function createBaseListRecentlyActiveRunsResponse(): ListRecentlyActiveRunsResponse {
  return { runIds: [] };
}

export const ListRecentlyActiveRunsResponse: MessageFns<ListRecentlyActiveRunsResponse> = {
  encode(message: ListRecentlyActiveRunsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.runIds) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRecentlyActiveRunsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRecentlyActiveRunsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.runIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRecentlyActiveRunsResponse {
    return {
      runIds: globalThis.Array.isArray(object?.runIds) ? object.runIds.map((e: any) => globalThis.String(e)) : [],
    };
  },

  toJSON(message: ListRecentlyActiveRunsResponse): unknown {
    const obj: any = {};
    if (message.runIds?.length) {
      obj.runIds = message.runIds;
    }
    return obj;
  },

  create(base?: DeepPartial<ListRecentlyActiveRunsResponse>): ListRecentlyActiveRunsResponse {
    return ListRecentlyActiveRunsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListRecentlyActiveRunsResponse>): ListRecentlyActiveRunsResponse {
    const message = createBaseListRecentlyActiveRunsResponse();
    message.runIds = object.runIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseListRecentlyActiveSessionsRequest(): ListRecentlyActiveSessionsRequest {
  return { since: Long.ZERO };
}

export const ListRecentlyActiveSessionsRequest: MessageFns<ListRecentlyActiveSessionsRequest> = {
  encode(message: ListRecentlyActiveSessionsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (!message.since.equals(Long.ZERO)) {
      writer.uint32(8).int64(message.since.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRecentlyActiveSessionsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRecentlyActiveSessionsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.since = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRecentlyActiveSessionsRequest {
    return { since: isSet(object.since) ? Long.fromValue(object.since) : Long.ZERO };
  },

  toJSON(message: ListRecentlyActiveSessionsRequest): unknown {
    const obj: any = {};
    if (!message.since.equals(Long.ZERO)) {
      obj.since = (message.since || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<ListRecentlyActiveSessionsRequest>): ListRecentlyActiveSessionsRequest {
    return ListRecentlyActiveSessionsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListRecentlyActiveSessionsRequest>): ListRecentlyActiveSessionsRequest {
    const message = createBaseListRecentlyActiveSessionsRequest();
    message.since = (object.since !== undefined && object.since !== null) ? Long.fromValue(object.since) : Long.ZERO;
    return message;
  },
};

function createBaseListRecentlyActiveSessionsResponse(): ListRecentlyActiveSessionsResponse {
  return { sessionIds: [] };
}

export const ListRecentlyActiveSessionsResponse: MessageFns<ListRecentlyActiveSessionsResponse> = {
  encode(message: ListRecentlyActiveSessionsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.sessionIds) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListRecentlyActiveSessionsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListRecentlyActiveSessionsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sessionIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListRecentlyActiveSessionsResponse {
    return {
      sessionIds: globalThis.Array.isArray(object?.sessionIds)
        ? object.sessionIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListRecentlyActiveSessionsResponse): unknown {
    const obj: any = {};
    if (message.sessionIds?.length) {
      obj.sessionIds = message.sessionIds;
    }
    return obj;
  },

  create(base?: DeepPartial<ListRecentlyActiveSessionsResponse>): ListRecentlyActiveSessionsResponse {
    return ListRecentlyActiveSessionsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListRecentlyActiveSessionsResponse>): ListRecentlyActiveSessionsResponse {
    const message = createBaseListRecentlyActiveSessionsResponse();
    message.sessionIds = object.sessionIds?.map((e) => e) || [];
    return message;
  },
};

export type McpManagerService = typeof McpManagerService;
export const McpManagerService = {
  ping: {
    path: "/broker.manager.McpManager/Ping",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    requestDeserialize: (value: Buffer): Empty => Empty.decode(value),
    responseSerialize: (value: Empty): Buffer => Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer): Empty => Empty.decode(value),
  },
  createSession: {
    path: "/broker.manager.McpManager/CreateSession",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateSessionRequest): Buffer => Buffer.from(CreateSessionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateSessionRequest => CreateSessionRequest.decode(value),
    responseSerialize: (value: CreateSessionResponse): Buffer =>
      Buffer.from(CreateSessionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): CreateSessionResponse => CreateSessionResponse.decode(value),
  },
  discardSession: {
    path: "/broker.manager.McpManager/DiscardSession",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: DiscardSessionRequest): Buffer =>
      Buffer.from(DiscardSessionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): DiscardSessionRequest => DiscardSessionRequest.decode(value),
    responseSerialize: (value: DiscardSessionResponse): Buffer =>
      Buffer.from(DiscardSessionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): DiscardSessionResponse => DiscardSessionResponse.decode(value),
  },
  sendMcpMessage: {
    path: "/broker.manager.McpManager/SendMcpMessage",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: SendMcpMessageRequest): Buffer =>
      Buffer.from(SendMcpMessageRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): SendMcpMessageRequest => SendMcpMessageRequest.decode(value),
    responseSerialize: (value: SendMcpMessageResponse): Buffer =>
      Buffer.from(SendMcpMessageResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): SendMcpMessageResponse => SendMcpMessageResponse.decode(value),
  },
  streamMcpMessages: {
    path: "/broker.manager.McpManager/StreamMcpMessages",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: StreamMcpMessagesRequest): Buffer =>
      Buffer.from(StreamMcpMessagesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): StreamMcpMessagesRequest => StreamMcpMessagesRequest.decode(value),
    responseSerialize: (value: StreamMcpMessagesResponse): Buffer =>
      Buffer.from(StreamMcpMessagesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): StreamMcpMessagesResponse => StreamMcpMessagesResponse.decode(value),
  },
  getServerInfo: {
    path: "/broker.manager.McpManager/GetServerInfo",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetServerInfoRequest): Buffer => Buffer.from(GetServerInfoRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetServerInfoRequest => GetServerInfoRequest.decode(value),
    responseSerialize: (value: McpParticipant): Buffer => Buffer.from(McpParticipant.encode(value).finish()),
    responseDeserialize: (value: Buffer): McpParticipant => McpParticipant.decode(value),
  },
  listManagers: {
    path: "/broker.manager.McpManager/ListManagers",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListManagersRequest): Buffer => Buffer.from(ListManagersRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListManagersRequest => ListManagersRequest.decode(value),
    responseSerialize: (value: ListManagersResponse): Buffer =>
      Buffer.from(ListManagersResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListManagersResponse => ListManagersResponse.decode(value),
  },
  listWorkers: {
    path: "/broker.manager.McpManager/ListWorkers",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListWorkersRequest): Buffer => Buffer.from(ListWorkersRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListWorkersRequest => ListWorkersRequest.decode(value),
    responseSerialize: (value: ListWorkersResponse): Buffer => Buffer.from(ListWorkersResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListWorkersResponse => ListWorkersResponse.decode(value),
  },
  listSessions: {
    path: "/broker.manager.McpManager/ListSessions",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListSessionsRequest): Buffer => Buffer.from(ListSessionsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListSessionsRequest => ListSessionsRequest.decode(value),
    responseSerialize: (value: ListSessionsResponse): Buffer =>
      Buffer.from(ListSessionsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListSessionsResponse => ListSessionsResponse.decode(value),
  },
  getSession: {
    path: "/broker.manager.McpManager/GetSession",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetSessionRequest): Buffer => Buffer.from(GetSessionRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetSessionRequest => GetSessionRequest.decode(value),
    responseSerialize: (value: GetSessionResponse): Buffer => Buffer.from(GetSessionResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetSessionResponse => GetSessionResponse.decode(value),
  },
  listRuns: {
    path: "/broker.manager.McpManager/ListRuns",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListRunsRequest): Buffer => Buffer.from(ListRunsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListRunsRequest => ListRunsRequest.decode(value),
    responseSerialize: (value: ListRunsResponse): Buffer => Buffer.from(ListRunsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListRunsResponse => ListRunsResponse.decode(value),
  },
  getRun: {
    path: "/broker.manager.McpManager/GetRun",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetRunRequest): Buffer => Buffer.from(GetRunRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetRunRequest => GetRunRequest.decode(value),
    responseSerialize: (value: GetRunResponse): Buffer => Buffer.from(GetRunResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetRunResponse => GetRunResponse.decode(value),
  },
  listSessionErrors: {
    path: "/broker.manager.McpManager/ListSessionErrors",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListSessionErrorsRequest): Buffer =>
      Buffer.from(ListSessionErrorsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListSessionErrorsRequest => ListSessionErrorsRequest.decode(value),
    responseSerialize: (value: ListSessionErrorsResponse): Buffer =>
      Buffer.from(ListSessionErrorsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListSessionErrorsResponse => ListSessionErrorsResponse.decode(value),
  },
  listSessionEvents: {
    path: "/broker.manager.McpManager/ListSessionEvents",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListSessionEventsRequest): Buffer =>
      Buffer.from(ListSessionEventsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListSessionEventsRequest => ListSessionEventsRequest.decode(value),
    responseSerialize: (value: ListSessionEventsResponse): Buffer =>
      Buffer.from(ListSessionEventsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListSessionEventsResponse => ListSessionEventsResponse.decode(value),
  },
  listSessionMessages: {
    path: "/broker.manager.McpManager/ListSessionMessages",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListSessionMessagesRequest): Buffer =>
      Buffer.from(ListSessionMessagesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListSessionMessagesRequest => ListSessionMessagesRequest.decode(value),
    responseSerialize: (value: ListSessionMessagesResponse): Buffer =>
      Buffer.from(ListSessionMessagesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListSessionMessagesResponse => ListSessionMessagesResponse.decode(value),
  },
  listRunErrors: {
    path: "/broker.manager.McpManager/ListRunErrors",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListRunErrorsRequest): Buffer => Buffer.from(ListRunErrorsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListRunErrorsRequest => ListRunErrorsRequest.decode(value),
    responseSerialize: (value: ListRunErrorsResponse): Buffer =>
      Buffer.from(ListRunErrorsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListRunErrorsResponse => ListRunErrorsResponse.decode(value),
  },
  listRunEvents: {
    path: "/broker.manager.McpManager/ListRunEvents",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListRunEventsRequest): Buffer => Buffer.from(ListRunEventsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListRunEventsRequest => ListRunEventsRequest.decode(value),
    responseSerialize: (value: ListRunEventsResponse): Buffer =>
      Buffer.from(ListRunEventsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListRunEventsResponse => ListRunEventsResponse.decode(value),
  },
  listRunMessages: {
    path: "/broker.manager.McpManager/ListRunMessages",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListRunMessagesRequest): Buffer =>
      Buffer.from(ListRunMessagesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListRunMessagesRequest => ListRunMessagesRequest.decode(value),
    responseSerialize: (value: ListRunMessagesResponse): Buffer =>
      Buffer.from(ListRunMessagesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListRunMessagesResponse => ListRunMessagesResponse.decode(value),
  },
  getError: {
    path: "/broker.manager.McpManager/GetError",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetErrorRequest): Buffer => Buffer.from(GetErrorRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetErrorRequest => GetErrorRequest.decode(value),
    responseSerialize: (value: GetErrorResponse): Buffer => Buffer.from(GetErrorResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetErrorResponse => GetErrorResponse.decode(value),
  },
  getEvent: {
    path: "/broker.manager.McpManager/GetEvent",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetEventRequest): Buffer => Buffer.from(GetEventRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetEventRequest => GetEventRequest.decode(value),
    responseSerialize: (value: GetEventResponse): Buffer => Buffer.from(GetEventResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetEventResponse => GetEventResponse.decode(value),
  },
  getMessage: {
    path: "/broker.manager.McpManager/GetMessage",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetMessageRequest): Buffer => Buffer.from(GetMessageRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetMessageRequest => GetMessageRequest.decode(value),
    responseSerialize: (value: GetMessageResponse): Buffer => Buffer.from(GetMessageResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetMessageResponse => GetMessageResponse.decode(value),
  },
  listRecentlyActiveRuns: {
    path: "/broker.manager.McpManager/ListRecentlyActiveRuns",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListRecentlyActiveRunsRequest): Buffer =>
      Buffer.from(ListRecentlyActiveRunsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListRecentlyActiveRunsRequest => ListRecentlyActiveRunsRequest.decode(value),
    responseSerialize: (value: ListRecentlyActiveRunsResponse): Buffer =>
      Buffer.from(ListRecentlyActiveRunsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListRecentlyActiveRunsResponse =>
      ListRecentlyActiveRunsResponse.decode(value),
  },
  listRecentlyActiveSessions: {
    path: "/broker.manager.McpManager/ListRecentlyActiveSessions",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListRecentlyActiveSessionsRequest): Buffer =>
      Buffer.from(ListRecentlyActiveSessionsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListRecentlyActiveSessionsRequest =>
      ListRecentlyActiveSessionsRequest.decode(value),
    responseSerialize: (value: ListRecentlyActiveSessionsResponse): Buffer =>
      Buffer.from(ListRecentlyActiveSessionsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListRecentlyActiveSessionsResponse =>
      ListRecentlyActiveSessionsResponse.decode(value),
  },
} as const;

export interface McpManagerServer extends UntypedServiceImplementation {
  ping: handleUnaryCall<Empty, Empty>;
  createSession: handleUnaryCall<CreateSessionRequest, CreateSessionResponse>;
  discardSession: handleUnaryCall<DiscardSessionRequest, DiscardSessionResponse>;
  sendMcpMessage: handleServerStreamingCall<SendMcpMessageRequest, SendMcpMessageResponse>;
  streamMcpMessages: handleServerStreamingCall<StreamMcpMessagesRequest, StreamMcpMessagesResponse>;
  getServerInfo: handleUnaryCall<GetServerInfoRequest, McpParticipant>;
  listManagers: handleUnaryCall<ListManagersRequest, ListManagersResponse>;
  listWorkers: handleUnaryCall<ListWorkersRequest, ListWorkersResponse>;
  listSessions: handleUnaryCall<ListSessionsRequest, ListSessionsResponse>;
  getSession: handleUnaryCall<GetSessionRequest, GetSessionResponse>;
  listRuns: handleUnaryCall<ListRunsRequest, ListRunsResponse>;
  getRun: handleUnaryCall<GetRunRequest, GetRunResponse>;
  listSessionErrors: handleUnaryCall<ListSessionErrorsRequest, ListSessionErrorsResponse>;
  listSessionEvents: handleUnaryCall<ListSessionEventsRequest, ListSessionEventsResponse>;
  listSessionMessages: handleUnaryCall<ListSessionMessagesRequest, ListSessionMessagesResponse>;
  listRunErrors: handleUnaryCall<ListRunErrorsRequest, ListRunErrorsResponse>;
  listRunEvents: handleUnaryCall<ListRunEventsRequest, ListRunEventsResponse>;
  listRunMessages: handleUnaryCall<ListRunMessagesRequest, ListRunMessagesResponse>;
  getError: handleUnaryCall<GetErrorRequest, GetErrorResponse>;
  getEvent: handleUnaryCall<GetEventRequest, GetEventResponse>;
  getMessage: handleUnaryCall<GetMessageRequest, GetMessageResponse>;
  listRecentlyActiveRuns: handleUnaryCall<ListRecentlyActiveRunsRequest, ListRecentlyActiveRunsResponse>;
  listRecentlyActiveSessions: handleUnaryCall<ListRecentlyActiveSessionsRequest, ListRecentlyActiveSessionsResponse>;
}

export interface McpManagerClient extends Client {
  ping(request: Empty, callback: (error: ServiceError | null, response: Empty) => void): ClientUnaryCall;
  ping(
    request: Empty,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  ping(
    request: Empty,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall;
  createSession(
    request: CreateSessionRequest,
    callback: (error: ServiceError | null, response: CreateSessionResponse) => void,
  ): ClientUnaryCall;
  createSession(
    request: CreateSessionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CreateSessionResponse) => void,
  ): ClientUnaryCall;
  createSession(
    request: CreateSessionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CreateSessionResponse) => void,
  ): ClientUnaryCall;
  discardSession(
    request: DiscardSessionRequest,
    callback: (error: ServiceError | null, response: DiscardSessionResponse) => void,
  ): ClientUnaryCall;
  discardSession(
    request: DiscardSessionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: DiscardSessionResponse) => void,
  ): ClientUnaryCall;
  discardSession(
    request: DiscardSessionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: DiscardSessionResponse) => void,
  ): ClientUnaryCall;
  sendMcpMessage(
    request: SendMcpMessageRequest,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<SendMcpMessageResponse>;
  sendMcpMessage(
    request: SendMcpMessageRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<SendMcpMessageResponse>;
  streamMcpMessages(
    request: StreamMcpMessagesRequest,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<StreamMcpMessagesResponse>;
  streamMcpMessages(
    request: StreamMcpMessagesRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<StreamMcpMessagesResponse>;
  getServerInfo(
    request: GetServerInfoRequest,
    callback: (error: ServiceError | null, response: McpParticipant) => void,
  ): ClientUnaryCall;
  getServerInfo(
    request: GetServerInfoRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: McpParticipant) => void,
  ): ClientUnaryCall;
  getServerInfo(
    request: GetServerInfoRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: McpParticipant) => void,
  ): ClientUnaryCall;
  listManagers(
    request: ListManagersRequest,
    callback: (error: ServiceError | null, response: ListManagersResponse) => void,
  ): ClientUnaryCall;
  listManagers(
    request: ListManagersRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListManagersResponse) => void,
  ): ClientUnaryCall;
  listManagers(
    request: ListManagersRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListManagersResponse) => void,
  ): ClientUnaryCall;
  listWorkers(
    request: ListWorkersRequest,
    callback: (error: ServiceError | null, response: ListWorkersResponse) => void,
  ): ClientUnaryCall;
  listWorkers(
    request: ListWorkersRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListWorkersResponse) => void,
  ): ClientUnaryCall;
  listWorkers(
    request: ListWorkersRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListWorkersResponse) => void,
  ): ClientUnaryCall;
  listSessions(
    request: ListSessionsRequest,
    callback: (error: ServiceError | null, response: ListSessionsResponse) => void,
  ): ClientUnaryCall;
  listSessions(
    request: ListSessionsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListSessionsResponse) => void,
  ): ClientUnaryCall;
  listSessions(
    request: ListSessionsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListSessionsResponse) => void,
  ): ClientUnaryCall;
  getSession(
    request: GetSessionRequest,
    callback: (error: ServiceError | null, response: GetSessionResponse) => void,
  ): ClientUnaryCall;
  getSession(
    request: GetSessionRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetSessionResponse) => void,
  ): ClientUnaryCall;
  getSession(
    request: GetSessionRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetSessionResponse) => void,
  ): ClientUnaryCall;
  listRuns(
    request: ListRunsRequest,
    callback: (error: ServiceError | null, response: ListRunsResponse) => void,
  ): ClientUnaryCall;
  listRuns(
    request: ListRunsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListRunsResponse) => void,
  ): ClientUnaryCall;
  listRuns(
    request: ListRunsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListRunsResponse) => void,
  ): ClientUnaryCall;
  getRun(
    request: GetRunRequest,
    callback: (error: ServiceError | null, response: GetRunResponse) => void,
  ): ClientUnaryCall;
  getRun(
    request: GetRunRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetRunResponse) => void,
  ): ClientUnaryCall;
  getRun(
    request: GetRunRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetRunResponse) => void,
  ): ClientUnaryCall;
  listSessionErrors(
    request: ListSessionErrorsRequest,
    callback: (error: ServiceError | null, response: ListSessionErrorsResponse) => void,
  ): ClientUnaryCall;
  listSessionErrors(
    request: ListSessionErrorsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListSessionErrorsResponse) => void,
  ): ClientUnaryCall;
  listSessionErrors(
    request: ListSessionErrorsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListSessionErrorsResponse) => void,
  ): ClientUnaryCall;
  listSessionEvents(
    request: ListSessionEventsRequest,
    callback: (error: ServiceError | null, response: ListSessionEventsResponse) => void,
  ): ClientUnaryCall;
  listSessionEvents(
    request: ListSessionEventsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListSessionEventsResponse) => void,
  ): ClientUnaryCall;
  listSessionEvents(
    request: ListSessionEventsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListSessionEventsResponse) => void,
  ): ClientUnaryCall;
  listSessionMessages(
    request: ListSessionMessagesRequest,
    callback: (error: ServiceError | null, response: ListSessionMessagesResponse) => void,
  ): ClientUnaryCall;
  listSessionMessages(
    request: ListSessionMessagesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListSessionMessagesResponse) => void,
  ): ClientUnaryCall;
  listSessionMessages(
    request: ListSessionMessagesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListSessionMessagesResponse) => void,
  ): ClientUnaryCall;
  listRunErrors(
    request: ListRunErrorsRequest,
    callback: (error: ServiceError | null, response: ListRunErrorsResponse) => void,
  ): ClientUnaryCall;
  listRunErrors(
    request: ListRunErrorsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListRunErrorsResponse) => void,
  ): ClientUnaryCall;
  listRunErrors(
    request: ListRunErrorsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListRunErrorsResponse) => void,
  ): ClientUnaryCall;
  listRunEvents(
    request: ListRunEventsRequest,
    callback: (error: ServiceError | null, response: ListRunEventsResponse) => void,
  ): ClientUnaryCall;
  listRunEvents(
    request: ListRunEventsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListRunEventsResponse) => void,
  ): ClientUnaryCall;
  listRunEvents(
    request: ListRunEventsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListRunEventsResponse) => void,
  ): ClientUnaryCall;
  listRunMessages(
    request: ListRunMessagesRequest,
    callback: (error: ServiceError | null, response: ListRunMessagesResponse) => void,
  ): ClientUnaryCall;
  listRunMessages(
    request: ListRunMessagesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListRunMessagesResponse) => void,
  ): ClientUnaryCall;
  listRunMessages(
    request: ListRunMessagesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListRunMessagesResponse) => void,
  ): ClientUnaryCall;
  getError(
    request: GetErrorRequest,
    callback: (error: ServiceError | null, response: GetErrorResponse) => void,
  ): ClientUnaryCall;
  getError(
    request: GetErrorRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetErrorResponse) => void,
  ): ClientUnaryCall;
  getError(
    request: GetErrorRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetErrorResponse) => void,
  ): ClientUnaryCall;
  getEvent(
    request: GetEventRequest,
    callback: (error: ServiceError | null, response: GetEventResponse) => void,
  ): ClientUnaryCall;
  getEvent(
    request: GetEventRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetEventResponse) => void,
  ): ClientUnaryCall;
  getEvent(
    request: GetEventRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetEventResponse) => void,
  ): ClientUnaryCall;
  getMessage(
    request: GetMessageRequest,
    callback: (error: ServiceError | null, response: GetMessageResponse) => void,
  ): ClientUnaryCall;
  getMessage(
    request: GetMessageRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetMessageResponse) => void,
  ): ClientUnaryCall;
  getMessage(
    request: GetMessageRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetMessageResponse) => void,
  ): ClientUnaryCall;
  listRecentlyActiveRuns(
    request: ListRecentlyActiveRunsRequest,
    callback: (error: ServiceError | null, response: ListRecentlyActiveRunsResponse) => void,
  ): ClientUnaryCall;
  listRecentlyActiveRuns(
    request: ListRecentlyActiveRunsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListRecentlyActiveRunsResponse) => void,
  ): ClientUnaryCall;
  listRecentlyActiveRuns(
    request: ListRecentlyActiveRunsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListRecentlyActiveRunsResponse) => void,
  ): ClientUnaryCall;
  listRecentlyActiveSessions(
    request: ListRecentlyActiveSessionsRequest,
    callback: (error: ServiceError | null, response: ListRecentlyActiveSessionsResponse) => void,
  ): ClientUnaryCall;
  listRecentlyActiveSessions(
    request: ListRecentlyActiveSessionsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListRecentlyActiveSessionsResponse) => void,
  ): ClientUnaryCall;
  listRecentlyActiveSessions(
    request: ListRecentlyActiveSessionsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListRecentlyActiveSessionsResponse) => void,
  ): ClientUnaryCall;
}

export const McpManagerClient = makeGenericClientConstructor(
  McpManagerService,
  "broker.manager.McpManager",
) as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): McpManagerClient;
  service: typeof McpManagerService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
