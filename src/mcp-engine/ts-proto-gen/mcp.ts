// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v6.31.1
// source: mcp.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import Long from "long";

export const protobufPackage = "broker.mcp";

export enum McpMessageType {
  request = 0,
  response = 1,
  notification = 2,
  error = 3,
  unknown = 4,
  UNRECOGNIZED = -1,
}

export function mcpMessageTypeFromJSON(object: any): McpMessageType {
  switch (object) {
    case 0:
    case "request":
      return McpMessageType.request;
    case 1:
    case "response":
      return McpMessageType.response;
    case 2:
    case "notification":
      return McpMessageType.notification;
    case 3:
    case "error":
      return McpMessageType.error;
    case 4:
    case "unknown":
      return McpMessageType.unknown;
    case -1:
    case "UNRECOGNIZED":
    default:
      return McpMessageType.UNRECOGNIZED;
  }
}

export function mcpMessageTypeToJSON(object: McpMessageType): string {
  switch (object) {
    case McpMessageType.request:
      return "request";
    case McpMessageType.response:
      return "response";
    case McpMessageType.notification:
      return "notification";
    case McpMessageType.error:
      return "error";
    case McpMessageType.unknown:
      return "unknown";
    case McpMessageType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface McpError {
  errorMessage: string;
  errorCode: McpError_McpErrorCode;
  /** Optional, Additional metadata for the error */
  metadata: { [key: string]: string };
  /** UUID for tracking the error */
  uuid: string;
}

export enum McpError_McpErrorCode {
  failed_to_start = 0,
  failed_to_stop = 1,
  invalid_mcp_message = 2,
  unknown_error = 3,
  timeout = 4,
  launch_params_error = 5,
  execution_error = 6,
  UNRECOGNIZED = -1,
}

export function mcpError_McpErrorCodeFromJSON(object: any): McpError_McpErrorCode {
  switch (object) {
    case 0:
    case "failed_to_start":
      return McpError_McpErrorCode.failed_to_start;
    case 1:
    case "failed_to_stop":
      return McpError_McpErrorCode.failed_to_stop;
    case 2:
    case "invalid_mcp_message":
      return McpError_McpErrorCode.invalid_mcp_message;
    case 3:
    case "unknown_error":
      return McpError_McpErrorCode.unknown_error;
    case 4:
    case "timeout":
      return McpError_McpErrorCode.timeout;
    case 5:
    case "launch_params_error":
      return McpError_McpErrorCode.launch_params_error;
    case 6:
    case "execution_error":
      return McpError_McpErrorCode.execution_error;
    case -1:
    case "UNRECOGNIZED":
    default:
      return McpError_McpErrorCode.UNRECOGNIZED;
  }
}

export function mcpError_McpErrorCodeToJSON(object: McpError_McpErrorCode): string {
  switch (object) {
    case McpError_McpErrorCode.failed_to_start:
      return "failed_to_start";
    case McpError_McpErrorCode.failed_to_stop:
      return "failed_to_stop";
    case McpError_McpErrorCode.invalid_mcp_message:
      return "invalid_mcp_message";
    case McpError_McpErrorCode.unknown_error:
      return "unknown_error";
    case McpError_McpErrorCode.timeout:
      return "timeout";
    case McpError_McpErrorCode.launch_params_error:
      return "launch_params_error";
    case McpError_McpErrorCode.execution_error:
      return "execution_error";
    case McpError_McpErrorCode.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface McpError_MetadataEntry {
  key: string;
  value: string;
}

export interface McpOutput {
  outputType: McpOutput_McpOutputType;
  lines: string[];
  /** UUID for tracking the output */
  uuid: string;
}

export enum McpOutput_McpOutputType {
  stdout = 0,
  stderr = 1,
  /** remote - Output from a remote source */
  remote = 2,
  UNRECOGNIZED = -1,
}

export function mcpOutput_McpOutputTypeFromJSON(object: any): McpOutput_McpOutputType {
  switch (object) {
    case 0:
    case "stdout":
      return McpOutput_McpOutputType.stdout;
    case 1:
    case "stderr":
      return McpOutput_McpOutputType.stderr;
    case 2:
    case "remote":
      return McpOutput_McpOutputType.remote;
    case -1:
    case "UNRECOGNIZED":
    default:
      return McpOutput_McpOutputType.UNRECOGNIZED;
  }
}

export function mcpOutput_McpOutputTypeToJSON(object: McpOutput_McpOutputType): string {
  switch (object) {
    case McpOutput_McpOutputType.stdout:
      return "stdout";
    case McpOutput_McpOutputType.stderr:
      return "stderr";
    case McpOutput_McpOutputType.remote:
      return "remote";
    case McpOutput_McpOutputType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface McpMessageRaw {
  message: string;
  /** UUID for tracking the message */
  uuid: string;
}

export interface McpMessage {
  mcpMessage: McpMessageRaw | undefined;
  messageType: McpMessageType;
  /** Optional */
  idString: string;
  /** Optional */
  idJson: string;
  /** Optional */
  method: string;
}

export interface McpParticipant {
  type: McpParticipant_ParticipantType;
  participantJson: string;
}

export enum McpParticipant_ParticipantType {
  server = 0,
  client = 1,
  UNRECOGNIZED = -1,
}

export function mcpParticipant_ParticipantTypeFromJSON(object: any): McpParticipant_ParticipantType {
  switch (object) {
    case 0:
    case "server":
      return McpParticipant_ParticipantType.server;
    case 1:
    case "client":
      return McpParticipant_ParticipantType.client;
    case -1:
    case "UNRECOGNIZED":
    default:
      return McpParticipant_ParticipantType.UNRECOGNIZED;
  }
}

export function mcpParticipant_ParticipantTypeToJSON(object: McpParticipant_ParticipantType): string {
  switch (object) {
    case McpParticipant_ParticipantType.server:
      return "server";
    case McpParticipant_ParticipantType.client:
      return "client";
    case McpParticipant_ParticipantType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBaseMcpError(): McpError {
  return { errorMessage: "", errorCode: 0, metadata: {}, uuid: "" };
}

export const McpError: MessageFns<McpError> = {
  encode(message: McpError, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.errorMessage !== "") {
      writer.uint32(10).string(message.errorMessage);
    }
    if (message.errorCode !== 0) {
      writer.uint32(16).int32(message.errorCode);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      McpError_MetadataEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    if (message.uuid !== "") {
      writer.uint32(34).string(message.uuid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): McpError {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMcpError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.errorCode = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = McpError_MetadataEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.metadata[entry3.key] = entry3.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.uuid = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): McpError {
    return {
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
      errorCode: isSet(object.errorCode) ? mcpError_McpErrorCodeFromJSON(object.errorCode) : 0,
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      uuid: isSet(object.uuid) ? globalThis.String(object.uuid) : "",
    };
  },

  toJSON(message: McpError): unknown {
    const obj: any = {};
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    if (message.errorCode !== 0) {
      obj.errorCode = mcpError_McpErrorCodeToJSON(message.errorCode);
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.uuid !== "") {
      obj.uuid = message.uuid;
    }
    return obj;
  },

  create(base?: DeepPartial<McpError>): McpError {
    return McpError.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<McpError>): McpError {
    const message = createBaseMcpError();
    message.errorMessage = object.errorMessage ?? "";
    message.errorCode = object.errorCode ?? 0;
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.uuid = object.uuid ?? "";
    return message;
  },
};

function createBaseMcpError_MetadataEntry(): McpError_MetadataEntry {
  return { key: "", value: "" };
}

export const McpError_MetadataEntry: MessageFns<McpError_MetadataEntry> = {
  encode(message: McpError_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): McpError_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMcpError_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): McpError_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: McpError_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<McpError_MetadataEntry>): McpError_MetadataEntry {
    return McpError_MetadataEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<McpError_MetadataEntry>): McpError_MetadataEntry {
    const message = createBaseMcpError_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseMcpOutput(): McpOutput {
  return { outputType: 0, lines: [], uuid: "" };
}

export const McpOutput: MessageFns<McpOutput> = {
  encode(message: McpOutput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.outputType !== 0) {
      writer.uint32(8).int32(message.outputType);
    }
    for (const v of message.lines) {
      writer.uint32(18).string(v!);
    }
    if (message.uuid !== "") {
      writer.uint32(26).string(message.uuid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): McpOutput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMcpOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.outputType = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.lines.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.uuid = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): McpOutput {
    return {
      outputType: isSet(object.outputType) ? mcpOutput_McpOutputTypeFromJSON(object.outputType) : 0,
      lines: globalThis.Array.isArray(object?.lines) ? object.lines.map((e: any) => globalThis.String(e)) : [],
      uuid: isSet(object.uuid) ? globalThis.String(object.uuid) : "",
    };
  },

  toJSON(message: McpOutput): unknown {
    const obj: any = {};
    if (message.outputType !== 0) {
      obj.outputType = mcpOutput_McpOutputTypeToJSON(message.outputType);
    }
    if (message.lines?.length) {
      obj.lines = message.lines;
    }
    if (message.uuid !== "") {
      obj.uuid = message.uuid;
    }
    return obj;
  },

  create(base?: DeepPartial<McpOutput>): McpOutput {
    return McpOutput.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<McpOutput>): McpOutput {
    const message = createBaseMcpOutput();
    message.outputType = object.outputType ?? 0;
    message.lines = object.lines?.map((e) => e) || [];
    message.uuid = object.uuid ?? "";
    return message;
  },
};

function createBaseMcpMessageRaw(): McpMessageRaw {
  return { message: "", uuid: "" };
}

export const McpMessageRaw: MessageFns<McpMessageRaw> = {
  encode(message: McpMessageRaw, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.message !== "") {
      writer.uint32(10).string(message.message);
    }
    if (message.uuid !== "") {
      writer.uint32(18).string(message.uuid);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): McpMessageRaw {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMcpMessageRaw();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.message = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.uuid = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): McpMessageRaw {
    return {
      message: isSet(object.message) ? globalThis.String(object.message) : "",
      uuid: isSet(object.uuid) ? globalThis.String(object.uuid) : "",
    };
  },

  toJSON(message: McpMessageRaw): unknown {
    const obj: any = {};
    if (message.message !== "") {
      obj.message = message.message;
    }
    if (message.uuid !== "") {
      obj.uuid = message.uuid;
    }
    return obj;
  },

  create(base?: DeepPartial<McpMessageRaw>): McpMessageRaw {
    return McpMessageRaw.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<McpMessageRaw>): McpMessageRaw {
    const message = createBaseMcpMessageRaw();
    message.message = object.message ?? "";
    message.uuid = object.uuid ?? "";
    return message;
  },
};

function createBaseMcpMessage(): McpMessage {
  return { mcpMessage: undefined, messageType: 0, idString: "", idJson: "", method: "" };
}

export const McpMessage: MessageFns<McpMessage> = {
  encode(message: McpMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.mcpMessage !== undefined) {
      McpMessageRaw.encode(message.mcpMessage, writer.uint32(10).fork()).join();
    }
    if (message.messageType !== 0) {
      writer.uint32(16).int32(message.messageType);
    }
    if (message.idString !== "") {
      writer.uint32(26).string(message.idString);
    }
    if (message.idJson !== "") {
      writer.uint32(34).string(message.idJson);
    }
    if (message.method !== "") {
      writer.uint32(42).string(message.method);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): McpMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMcpMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.mcpMessage = McpMessageRaw.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.messageType = reader.int32() as any;
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.idString = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.idJson = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.method = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): McpMessage {
    return {
      mcpMessage: isSet(object.mcpMessage) ? McpMessageRaw.fromJSON(object.mcpMessage) : undefined,
      messageType: isSet(object.messageType) ? mcpMessageTypeFromJSON(object.messageType) : 0,
      idString: isSet(object.idString) ? globalThis.String(object.idString) : "",
      idJson: isSet(object.idJson) ? globalThis.String(object.idJson) : "",
      method: isSet(object.method) ? globalThis.String(object.method) : "",
    };
  },

  toJSON(message: McpMessage): unknown {
    const obj: any = {};
    if (message.mcpMessage !== undefined) {
      obj.mcpMessage = McpMessageRaw.toJSON(message.mcpMessage);
    }
    if (message.messageType !== 0) {
      obj.messageType = mcpMessageTypeToJSON(message.messageType);
    }
    if (message.idString !== "") {
      obj.idString = message.idString;
    }
    if (message.idJson !== "") {
      obj.idJson = message.idJson;
    }
    if (message.method !== "") {
      obj.method = message.method;
    }
    return obj;
  },

  create(base?: DeepPartial<McpMessage>): McpMessage {
    return McpMessage.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<McpMessage>): McpMessage {
    const message = createBaseMcpMessage();
    message.mcpMessage = (object.mcpMessage !== undefined && object.mcpMessage !== null)
      ? McpMessageRaw.fromPartial(object.mcpMessage)
      : undefined;
    message.messageType = object.messageType ?? 0;
    message.idString = object.idString ?? "";
    message.idJson = object.idJson ?? "";
    message.method = object.method ?? "";
    return message;
  },
};

function createBaseMcpParticipant(): McpParticipant {
  return { type: 0, participantJson: "" };
}

export const McpParticipant: MessageFns<McpParticipant> = {
  encode(message: McpParticipant, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== 0) {
      writer.uint32(8).int32(message.type);
    }
    if (message.participantJson !== "") {
      writer.uint32(18).string(message.participantJson);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): McpParticipant {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMcpParticipant();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.type = reader.int32() as any;
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.participantJson = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): McpParticipant {
    return {
      type: isSet(object.type) ? mcpParticipant_ParticipantTypeFromJSON(object.type) : 0,
      participantJson: isSet(object.participantJson) ? globalThis.String(object.participantJson) : "",
    };
  },

  toJSON(message: McpParticipant): unknown {
    const obj: any = {};
    if (message.type !== 0) {
      obj.type = mcpParticipant_ParticipantTypeToJSON(message.type);
    }
    if (message.participantJson !== "") {
      obj.participantJson = message.participantJson;
    }
    return obj;
  },

  create(base?: DeepPartial<McpParticipant>): McpParticipant {
    return McpParticipant.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<McpParticipant>): McpParticipant {
    const message = createBaseMcpParticipant();
    message.type = object.type ?? 0;
    message.participantJson = object.participantJson ?? "";
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
