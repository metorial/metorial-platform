// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v6.31.1
// source: rpc.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  type ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  type Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import Long from "long";

export const protobufPackage = "rpc.rpc";

export interface CloneBucketRequest {
  sourceBucketId: string;
  name: string;
  newBucketId: string;
}

export interface CloneBucketResponse {
}

export interface GetBucketTokenRequest {
  bucketId: string;
  /** Optional, defaults to 24h */
  expiresInSeconds: Long;
}

export interface GetBucketTokenResponse {
  token: string;
}

export interface GetBucketFileRequest {
  bucketId: string;
  path: string;
}

export interface GetBucketFileResponse {
  content: Uint8Array;
  contentType: string;
  size: Long;
  modifiedAt: Long;
}

export interface GetBucketFilesRequest {
  bucketId: string;
  /** Optional filter */
  prefix: string;
}

export interface FileInfo {
  path: string;
  size: Long;
  contentType: string;
  modifiedAt: Long;
}

export interface GetBucketFilesResponse {
  files: FileInfo[];
}

export interface GetBucketFilesAsZipRequest {
  bucketId: string;
  /** Optional filter */
  prefix: string;
}

export interface GetBucketFilesAsZipResponse {
  downloadUrl: string;
  expiresAt: Long;
}

function createBaseCloneBucketRequest(): CloneBucketRequest {
  return { sourceBucketId: "", name: "", newBucketId: "" };
}

export const CloneBucketRequest: MessageFns<CloneBucketRequest> = {
  encode(message: CloneBucketRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sourceBucketId !== "") {
      writer.uint32(10).string(message.sourceBucketId);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.newBucketId !== "") {
      writer.uint32(26).string(message.newBucketId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CloneBucketRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCloneBucketRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sourceBucketId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.newBucketId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CloneBucketRequest {
    return {
      sourceBucketId: isSet(object.sourceBucketId) ? globalThis.String(object.sourceBucketId) : "",
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      newBucketId: isSet(object.newBucketId) ? globalThis.String(object.newBucketId) : "",
    };
  },

  toJSON(message: CloneBucketRequest): unknown {
    const obj: any = {};
    if (message.sourceBucketId !== "") {
      obj.sourceBucketId = message.sourceBucketId;
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.newBucketId !== "") {
      obj.newBucketId = message.newBucketId;
    }
    return obj;
  },

  create(base?: DeepPartial<CloneBucketRequest>): CloneBucketRequest {
    return CloneBucketRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CloneBucketRequest>): CloneBucketRequest {
    const message = createBaseCloneBucketRequest();
    message.sourceBucketId = object.sourceBucketId ?? "";
    message.name = object.name ?? "";
    message.newBucketId = object.newBucketId ?? "";
    return message;
  },
};

function createBaseCloneBucketResponse(): CloneBucketResponse {
  return {};
}

export const CloneBucketResponse: MessageFns<CloneBucketResponse> = {
  encode(_: CloneBucketResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CloneBucketResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCloneBucketResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CloneBucketResponse {
    return {};
  },

  toJSON(_: CloneBucketResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<CloneBucketResponse>): CloneBucketResponse {
    return CloneBucketResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<CloneBucketResponse>): CloneBucketResponse {
    const message = createBaseCloneBucketResponse();
    return message;
  },
};

function createBaseGetBucketTokenRequest(): GetBucketTokenRequest {
  return { bucketId: "", expiresInSeconds: Long.ZERO };
}

export const GetBucketTokenRequest: MessageFns<GetBucketTokenRequest> = {
  encode(message: GetBucketTokenRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bucketId !== "") {
      writer.uint32(10).string(message.bucketId);
    }
    if (!message.expiresInSeconds.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.expiresInSeconds.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBucketTokenRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBucketTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bucketId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.expiresInSeconds = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBucketTokenRequest {
    return {
      bucketId: isSet(object.bucketId) ? globalThis.String(object.bucketId) : "",
      expiresInSeconds: isSet(object.expiresInSeconds) ? Long.fromValue(object.expiresInSeconds) : Long.ZERO,
    };
  },

  toJSON(message: GetBucketTokenRequest): unknown {
    const obj: any = {};
    if (message.bucketId !== "") {
      obj.bucketId = message.bucketId;
    }
    if (!message.expiresInSeconds.equals(Long.ZERO)) {
      obj.expiresInSeconds = (message.expiresInSeconds || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<GetBucketTokenRequest>): GetBucketTokenRequest {
    return GetBucketTokenRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetBucketTokenRequest>): GetBucketTokenRequest {
    const message = createBaseGetBucketTokenRequest();
    message.bucketId = object.bucketId ?? "";
    message.expiresInSeconds = (object.expiresInSeconds !== undefined && object.expiresInSeconds !== null)
      ? Long.fromValue(object.expiresInSeconds)
      : Long.ZERO;
    return message;
  },
};

function createBaseGetBucketTokenResponse(): GetBucketTokenResponse {
  return { token: "" };
}

export const GetBucketTokenResponse: MessageFns<GetBucketTokenResponse> = {
  encode(message: GetBucketTokenResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBucketTokenResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBucketTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.token = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBucketTokenResponse {
    return { token: isSet(object.token) ? globalThis.String(object.token) : "" };
  },

  toJSON(message: GetBucketTokenResponse): unknown {
    const obj: any = {};
    if (message.token !== "") {
      obj.token = message.token;
    }
    return obj;
  },

  create(base?: DeepPartial<GetBucketTokenResponse>): GetBucketTokenResponse {
    return GetBucketTokenResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetBucketTokenResponse>): GetBucketTokenResponse {
    const message = createBaseGetBucketTokenResponse();
    message.token = object.token ?? "";
    return message;
  },
};

function createBaseGetBucketFileRequest(): GetBucketFileRequest {
  return { bucketId: "", path: "" };
}

export const GetBucketFileRequest: MessageFns<GetBucketFileRequest> = {
  encode(message: GetBucketFileRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bucketId !== "") {
      writer.uint32(10).string(message.bucketId);
    }
    if (message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBucketFileRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBucketFileRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bucketId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.path = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBucketFileRequest {
    return {
      bucketId: isSet(object.bucketId) ? globalThis.String(object.bucketId) : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
    };
  },

  toJSON(message: GetBucketFileRequest): unknown {
    const obj: any = {};
    if (message.bucketId !== "") {
      obj.bucketId = message.bucketId;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },

  create(base?: DeepPartial<GetBucketFileRequest>): GetBucketFileRequest {
    return GetBucketFileRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetBucketFileRequest>): GetBucketFileRequest {
    const message = createBaseGetBucketFileRequest();
    message.bucketId = object.bucketId ?? "";
    message.path = object.path ?? "";
    return message;
  },
};

function createBaseGetBucketFileResponse(): GetBucketFileResponse {
  return { content: new Uint8Array(0), contentType: "", size: Long.ZERO, modifiedAt: Long.ZERO };
}

export const GetBucketFileResponse: MessageFns<GetBucketFileResponse> = {
  encode(message: GetBucketFileResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.content.length !== 0) {
      writer.uint32(10).bytes(message.content);
    }
    if (message.contentType !== "") {
      writer.uint32(18).string(message.contentType);
    }
    if (!message.size.equals(Long.ZERO)) {
      writer.uint32(24).int64(message.size.toString());
    }
    if (!message.modifiedAt.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.modifiedAt.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBucketFileResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBucketFileResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.content = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.contentType = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.size = Long.fromString(reader.int64().toString());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.modifiedAt = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBucketFileResponse {
    return {
      content: isSet(object.content) ? bytesFromBase64(object.content) : new Uint8Array(0),
      contentType: isSet(object.contentType) ? globalThis.String(object.contentType) : "",
      size: isSet(object.size) ? Long.fromValue(object.size) : Long.ZERO,
      modifiedAt: isSet(object.modifiedAt) ? Long.fromValue(object.modifiedAt) : Long.ZERO,
    };
  },

  toJSON(message: GetBucketFileResponse): unknown {
    const obj: any = {};
    if (message.content.length !== 0) {
      obj.content = base64FromBytes(message.content);
    }
    if (message.contentType !== "") {
      obj.contentType = message.contentType;
    }
    if (!message.size.equals(Long.ZERO)) {
      obj.size = (message.size || Long.ZERO).toString();
    }
    if (!message.modifiedAt.equals(Long.ZERO)) {
      obj.modifiedAt = (message.modifiedAt || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<GetBucketFileResponse>): GetBucketFileResponse {
    return GetBucketFileResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetBucketFileResponse>): GetBucketFileResponse {
    const message = createBaseGetBucketFileResponse();
    message.content = object.content ?? new Uint8Array(0);
    message.contentType = object.contentType ?? "";
    message.size = (object.size !== undefined && object.size !== null) ? Long.fromValue(object.size) : Long.ZERO;
    message.modifiedAt = (object.modifiedAt !== undefined && object.modifiedAt !== null)
      ? Long.fromValue(object.modifiedAt)
      : Long.ZERO;
    return message;
  },
};

function createBaseGetBucketFilesRequest(): GetBucketFilesRequest {
  return { bucketId: "", prefix: "" };
}

export const GetBucketFilesRequest: MessageFns<GetBucketFilesRequest> = {
  encode(message: GetBucketFilesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bucketId !== "") {
      writer.uint32(10).string(message.bucketId);
    }
    if (message.prefix !== "") {
      writer.uint32(18).string(message.prefix);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBucketFilesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBucketFilesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bucketId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.prefix = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBucketFilesRequest {
    return {
      bucketId: isSet(object.bucketId) ? globalThis.String(object.bucketId) : "",
      prefix: isSet(object.prefix) ? globalThis.String(object.prefix) : "",
    };
  },

  toJSON(message: GetBucketFilesRequest): unknown {
    const obj: any = {};
    if (message.bucketId !== "") {
      obj.bucketId = message.bucketId;
    }
    if (message.prefix !== "") {
      obj.prefix = message.prefix;
    }
    return obj;
  },

  create(base?: DeepPartial<GetBucketFilesRequest>): GetBucketFilesRequest {
    return GetBucketFilesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetBucketFilesRequest>): GetBucketFilesRequest {
    const message = createBaseGetBucketFilesRequest();
    message.bucketId = object.bucketId ?? "";
    message.prefix = object.prefix ?? "";
    return message;
  },
};

function createBaseFileInfo(): FileInfo {
  return { path: "", size: Long.ZERO, contentType: "", modifiedAt: Long.ZERO };
}

export const FileInfo: MessageFns<FileInfo> = {
  encode(message: FileInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (!message.size.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.size.toString());
    }
    if (message.contentType !== "") {
      writer.uint32(26).string(message.contentType);
    }
    if (!message.modifiedAt.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.modifiedAt.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FileInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.size = Long.fromString(reader.int64().toString());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.contentType = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.modifiedAt = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileInfo {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      size: isSet(object.size) ? Long.fromValue(object.size) : Long.ZERO,
      contentType: isSet(object.contentType) ? globalThis.String(object.contentType) : "",
      modifiedAt: isSet(object.modifiedAt) ? Long.fromValue(object.modifiedAt) : Long.ZERO,
    };
  },

  toJSON(message: FileInfo): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (!message.size.equals(Long.ZERO)) {
      obj.size = (message.size || Long.ZERO).toString();
    }
    if (message.contentType !== "") {
      obj.contentType = message.contentType;
    }
    if (!message.modifiedAt.equals(Long.ZERO)) {
      obj.modifiedAt = (message.modifiedAt || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<FileInfo>): FileInfo {
    return FileInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FileInfo>): FileInfo {
    const message = createBaseFileInfo();
    message.path = object.path ?? "";
    message.size = (object.size !== undefined && object.size !== null) ? Long.fromValue(object.size) : Long.ZERO;
    message.contentType = object.contentType ?? "";
    message.modifiedAt = (object.modifiedAt !== undefined && object.modifiedAt !== null)
      ? Long.fromValue(object.modifiedAt)
      : Long.ZERO;
    return message;
  },
};

function createBaseGetBucketFilesResponse(): GetBucketFilesResponse {
  return { files: [] };
}

export const GetBucketFilesResponse: MessageFns<GetBucketFilesResponse> = {
  encode(message: GetBucketFilesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.files) {
      FileInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBucketFilesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBucketFilesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.files.push(FileInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBucketFilesResponse {
    return { files: globalThis.Array.isArray(object?.files) ? object.files.map((e: any) => FileInfo.fromJSON(e)) : [] };
  },

  toJSON(message: GetBucketFilesResponse): unknown {
    const obj: any = {};
    if (message.files?.length) {
      obj.files = message.files.map((e) => FileInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GetBucketFilesResponse>): GetBucketFilesResponse {
    return GetBucketFilesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetBucketFilesResponse>): GetBucketFilesResponse {
    const message = createBaseGetBucketFilesResponse();
    message.files = object.files?.map((e) => FileInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetBucketFilesAsZipRequest(): GetBucketFilesAsZipRequest {
  return { bucketId: "", prefix: "" };
}

export const GetBucketFilesAsZipRequest: MessageFns<GetBucketFilesAsZipRequest> = {
  encode(message: GetBucketFilesAsZipRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bucketId !== "") {
      writer.uint32(10).string(message.bucketId);
    }
    if (message.prefix !== "") {
      writer.uint32(18).string(message.prefix);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBucketFilesAsZipRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBucketFilesAsZipRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bucketId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.prefix = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBucketFilesAsZipRequest {
    return {
      bucketId: isSet(object.bucketId) ? globalThis.String(object.bucketId) : "",
      prefix: isSet(object.prefix) ? globalThis.String(object.prefix) : "",
    };
  },

  toJSON(message: GetBucketFilesAsZipRequest): unknown {
    const obj: any = {};
    if (message.bucketId !== "") {
      obj.bucketId = message.bucketId;
    }
    if (message.prefix !== "") {
      obj.prefix = message.prefix;
    }
    return obj;
  },

  create(base?: DeepPartial<GetBucketFilesAsZipRequest>): GetBucketFilesAsZipRequest {
    return GetBucketFilesAsZipRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetBucketFilesAsZipRequest>): GetBucketFilesAsZipRequest {
    const message = createBaseGetBucketFilesAsZipRequest();
    message.bucketId = object.bucketId ?? "";
    message.prefix = object.prefix ?? "";
    return message;
  },
};

function createBaseGetBucketFilesAsZipResponse(): GetBucketFilesAsZipResponse {
  return { downloadUrl: "", expiresAt: Long.ZERO };
}

export const GetBucketFilesAsZipResponse: MessageFns<GetBucketFilesAsZipResponse> = {
  encode(message: GetBucketFilesAsZipResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.downloadUrl !== "") {
      writer.uint32(10).string(message.downloadUrl);
    }
    if (!message.expiresAt.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.expiresAt.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBucketFilesAsZipResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBucketFilesAsZipResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.downloadUrl = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.expiresAt = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBucketFilesAsZipResponse {
    return {
      downloadUrl: isSet(object.downloadUrl) ? globalThis.String(object.downloadUrl) : "",
      expiresAt: isSet(object.expiresAt) ? Long.fromValue(object.expiresAt) : Long.ZERO,
    };
  },

  toJSON(message: GetBucketFilesAsZipResponse): unknown {
    const obj: any = {};
    if (message.downloadUrl !== "") {
      obj.downloadUrl = message.downloadUrl;
    }
    if (!message.expiresAt.equals(Long.ZERO)) {
      obj.expiresAt = (message.expiresAt || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<GetBucketFilesAsZipResponse>): GetBucketFilesAsZipResponse {
    return GetBucketFilesAsZipResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetBucketFilesAsZipResponse>): GetBucketFilesAsZipResponse {
    const message = createBaseGetBucketFilesAsZipResponse();
    message.downloadUrl = object.downloadUrl ?? "";
    message.expiresAt = (object.expiresAt !== undefined && object.expiresAt !== null)
      ? Long.fromValue(object.expiresAt)
      : Long.ZERO;
    return message;
  },
};

export type CodeBucketService = typeof CodeBucketService;
export const CodeBucketService = {
  cloneBucket: {
    path: "/rpc.rpc.CodeBucket/CloneBucket",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CloneBucketRequest): Buffer => Buffer.from(CloneBucketRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CloneBucketRequest => CloneBucketRequest.decode(value),
    responseSerialize: (value: CloneBucketResponse): Buffer => Buffer.from(CloneBucketResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): CloneBucketResponse => CloneBucketResponse.decode(value),
  },
  getBucketToken: {
    path: "/rpc.rpc.CodeBucket/GetBucketToken",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetBucketTokenRequest): Buffer =>
      Buffer.from(GetBucketTokenRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetBucketTokenRequest => GetBucketTokenRequest.decode(value),
    responseSerialize: (value: GetBucketTokenResponse): Buffer =>
      Buffer.from(GetBucketTokenResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetBucketTokenResponse => GetBucketTokenResponse.decode(value),
  },
  getBucketFile: {
    path: "/rpc.rpc.CodeBucket/GetBucketFile",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetBucketFileRequest): Buffer => Buffer.from(GetBucketFileRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetBucketFileRequest => GetBucketFileRequest.decode(value),
    responseSerialize: (value: GetBucketFileResponse): Buffer =>
      Buffer.from(GetBucketFileResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetBucketFileResponse => GetBucketFileResponse.decode(value),
  },
  getBucketFiles: {
    path: "/rpc.rpc.CodeBucket/GetBucketFiles",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetBucketFilesRequest): Buffer =>
      Buffer.from(GetBucketFilesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetBucketFilesRequest => GetBucketFilesRequest.decode(value),
    responseSerialize: (value: GetBucketFilesResponse): Buffer =>
      Buffer.from(GetBucketFilesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetBucketFilesResponse => GetBucketFilesResponse.decode(value),
  },
  getBucketFilesAsZip: {
    path: "/rpc.rpc.CodeBucket/GetBucketFilesAsZip",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetBucketFilesAsZipRequest): Buffer =>
      Buffer.from(GetBucketFilesAsZipRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetBucketFilesAsZipRequest => GetBucketFilesAsZipRequest.decode(value),
    responseSerialize: (value: GetBucketFilesAsZipResponse): Buffer =>
      Buffer.from(GetBucketFilesAsZipResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetBucketFilesAsZipResponse => GetBucketFilesAsZipResponse.decode(value),
  },
} as const;

export interface CodeBucketServer extends UntypedServiceImplementation {
  cloneBucket: handleUnaryCall<CloneBucketRequest, CloneBucketResponse>;
  getBucketToken: handleUnaryCall<GetBucketTokenRequest, GetBucketTokenResponse>;
  getBucketFile: handleUnaryCall<GetBucketFileRequest, GetBucketFileResponse>;
  getBucketFiles: handleUnaryCall<GetBucketFilesRequest, GetBucketFilesResponse>;
  getBucketFilesAsZip: handleUnaryCall<GetBucketFilesAsZipRequest, GetBucketFilesAsZipResponse>;
}

export interface CodeBucketClient extends Client {
  cloneBucket(
    request: CloneBucketRequest,
    callback: (error: ServiceError | null, response: CloneBucketResponse) => void,
  ): ClientUnaryCall;
  cloneBucket(
    request: CloneBucketRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CloneBucketResponse) => void,
  ): ClientUnaryCall;
  cloneBucket(
    request: CloneBucketRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CloneBucketResponse) => void,
  ): ClientUnaryCall;
  getBucketToken(
    request: GetBucketTokenRequest,
    callback: (error: ServiceError | null, response: GetBucketTokenResponse) => void,
  ): ClientUnaryCall;
  getBucketToken(
    request: GetBucketTokenRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetBucketTokenResponse) => void,
  ): ClientUnaryCall;
  getBucketToken(
    request: GetBucketTokenRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetBucketTokenResponse) => void,
  ): ClientUnaryCall;
  getBucketFile(
    request: GetBucketFileRequest,
    callback: (error: ServiceError | null, response: GetBucketFileResponse) => void,
  ): ClientUnaryCall;
  getBucketFile(
    request: GetBucketFileRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetBucketFileResponse) => void,
  ): ClientUnaryCall;
  getBucketFile(
    request: GetBucketFileRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetBucketFileResponse) => void,
  ): ClientUnaryCall;
  getBucketFiles(
    request: GetBucketFilesRequest,
    callback: (error: ServiceError | null, response: GetBucketFilesResponse) => void,
  ): ClientUnaryCall;
  getBucketFiles(
    request: GetBucketFilesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetBucketFilesResponse) => void,
  ): ClientUnaryCall;
  getBucketFiles(
    request: GetBucketFilesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetBucketFilesResponse) => void,
  ): ClientUnaryCall;
  getBucketFilesAsZip(
    request: GetBucketFilesAsZipRequest,
    callback: (error: ServiceError | null, response: GetBucketFilesAsZipResponse) => void,
  ): ClientUnaryCall;
  getBucketFilesAsZip(
    request: GetBucketFilesAsZipRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetBucketFilesAsZipResponse) => void,
  ): ClientUnaryCall;
  getBucketFilesAsZip(
    request: GetBucketFilesAsZipRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetBucketFilesAsZipResponse) => void,
  ): ClientUnaryCall;
}

export const CodeBucketClient = makeGenericClientConstructor(CodeBucketService, "rpc.rpc.CodeBucket") as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): CodeBucketClient;
  service: typeof CodeBucketService;
  serviceName: string;
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
