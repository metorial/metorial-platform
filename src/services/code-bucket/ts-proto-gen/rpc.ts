// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v6.31.1
// source: rpc.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  type ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  type Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import Long from "long";

export const protobufPackage = "rpc.rpc";

export interface FileInfo {
  path: string;
  size: Long;
  contentType: string;
  modifiedAt: Long;
}

export interface FileContent {
  content: Uint8Array;
  fileInfo: FileInfo | undefined;
}

export interface CloneBucketRequest {
  sourceBucketId: string;
  newBucketId: string;
}

export interface CreateBucketFromZipRequest {
  newBucketId: string;
  zipUrl: string;
  path: string;
  headers: { [key: string]: string };
}

export interface CreateBucketFromZipRequest_HeadersEntry {
  key: string;
  value: string;
}

export interface CreateBucketFromGithubRequest {
  newBucketId: string;
  owner: string;
  repo: string;
  path: string;
  ref: string;
  token: string;
}

export interface CreateBucketResponse {
}

export interface GetBucketTokenRequest {
  bucketId: string;
  expiresInSeconds: Long;
}

export interface GetBucketTokenResponse {
  token: string;
}

export interface GetBucketFileRequest {
  bucketId: string;
  path: string;
}

export interface GetBucketFileResponse {
  content: FileContent | undefined;
}

export interface GetBucketFilesRequest {
  bucketId: string;
  /** Optional filter */
  prefix: string;
}

export interface GetBucketFilesResponse {
  files: FileInfo[];
}

export interface GetBucketFilesWithContentResponse {
  files: FileContent[];
}

export interface GetBucketFilesAsZipRequest {
  bucketId: string;
  /** Optional filter */
  prefix: string;
}

export interface GetBucketFilesAsZipResponse {
  downloadUrl: string;
  expiresAt: Long;
}

function createBaseFileInfo(): FileInfo {
  return { path: "", size: Long.ZERO, contentType: "", modifiedAt: Long.ZERO };
}

export const FileInfo: MessageFns<FileInfo> = {
  encode(message: FileInfo, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (!message.size.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.size.toString());
    }
    if (message.contentType !== "") {
      writer.uint32(26).string(message.contentType);
    }
    if (!message.modifiedAt.equals(Long.ZERO)) {
      writer.uint32(32).int64(message.modifiedAt.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FileInfo {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileInfo();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.size = Long.fromString(reader.int64().toString());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.contentType = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.modifiedAt = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileInfo {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      size: isSet(object.size) ? Long.fromValue(object.size) : Long.ZERO,
      contentType: isSet(object.contentType) ? globalThis.String(object.contentType) : "",
      modifiedAt: isSet(object.modifiedAt) ? Long.fromValue(object.modifiedAt) : Long.ZERO,
    };
  },

  toJSON(message: FileInfo): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (!message.size.equals(Long.ZERO)) {
      obj.size = (message.size || Long.ZERO).toString();
    }
    if (message.contentType !== "") {
      obj.contentType = message.contentType;
    }
    if (!message.modifiedAt.equals(Long.ZERO)) {
      obj.modifiedAt = (message.modifiedAt || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<FileInfo>): FileInfo {
    return FileInfo.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FileInfo>): FileInfo {
    const message = createBaseFileInfo();
    message.path = object.path ?? "";
    message.size = (object.size !== undefined && object.size !== null) ? Long.fromValue(object.size) : Long.ZERO;
    message.contentType = object.contentType ?? "";
    message.modifiedAt = (object.modifiedAt !== undefined && object.modifiedAt !== null)
      ? Long.fromValue(object.modifiedAt)
      : Long.ZERO;
    return message;
  },
};

function createBaseFileContent(): FileContent {
  return { content: new Uint8Array(0), fileInfo: undefined };
}

export const FileContent: MessageFns<FileContent> = {
  encode(message: FileContent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.content.length !== 0) {
      writer.uint32(10).bytes(message.content);
    }
    if (message.fileInfo !== undefined) {
      FileInfo.encode(message.fileInfo, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FileContent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileContent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.content = reader.bytes();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.fileInfo = FileInfo.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileContent {
    return {
      content: isSet(object.content) ? bytesFromBase64(object.content) : new Uint8Array(0),
      fileInfo: isSet(object.fileInfo) ? FileInfo.fromJSON(object.fileInfo) : undefined,
    };
  },

  toJSON(message: FileContent): unknown {
    const obj: any = {};
    if (message.content.length !== 0) {
      obj.content = base64FromBytes(message.content);
    }
    if (message.fileInfo !== undefined) {
      obj.fileInfo = FileInfo.toJSON(message.fileInfo);
    }
    return obj;
  },

  create(base?: DeepPartial<FileContent>): FileContent {
    return FileContent.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<FileContent>): FileContent {
    const message = createBaseFileContent();
    message.content = object.content ?? new Uint8Array(0);
    message.fileInfo = (object.fileInfo !== undefined && object.fileInfo !== null)
      ? FileInfo.fromPartial(object.fileInfo)
      : undefined;
    return message;
  },
};

function createBaseCloneBucketRequest(): CloneBucketRequest {
  return { sourceBucketId: "", newBucketId: "" };
}

export const CloneBucketRequest: MessageFns<CloneBucketRequest> = {
  encode(message: CloneBucketRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sourceBucketId !== "") {
      writer.uint32(10).string(message.sourceBucketId);
    }
    if (message.newBucketId !== "") {
      writer.uint32(18).string(message.newBucketId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CloneBucketRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCloneBucketRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.sourceBucketId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.newBucketId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CloneBucketRequest {
    return {
      sourceBucketId: isSet(object.sourceBucketId) ? globalThis.String(object.sourceBucketId) : "",
      newBucketId: isSet(object.newBucketId) ? globalThis.String(object.newBucketId) : "",
    };
  },

  toJSON(message: CloneBucketRequest): unknown {
    const obj: any = {};
    if (message.sourceBucketId !== "") {
      obj.sourceBucketId = message.sourceBucketId;
    }
    if (message.newBucketId !== "") {
      obj.newBucketId = message.newBucketId;
    }
    return obj;
  },

  create(base?: DeepPartial<CloneBucketRequest>): CloneBucketRequest {
    return CloneBucketRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CloneBucketRequest>): CloneBucketRequest {
    const message = createBaseCloneBucketRequest();
    message.sourceBucketId = object.sourceBucketId ?? "";
    message.newBucketId = object.newBucketId ?? "";
    return message;
  },
};

function createBaseCreateBucketFromZipRequest(): CreateBucketFromZipRequest {
  return { newBucketId: "", zipUrl: "", path: "", headers: {} };
}

export const CreateBucketFromZipRequest: MessageFns<CreateBucketFromZipRequest> = {
  encode(message: CreateBucketFromZipRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.newBucketId !== "") {
      writer.uint32(10).string(message.newBucketId);
    }
    if (message.zipUrl !== "") {
      writer.uint32(18).string(message.zipUrl);
    }
    if (message.path !== "") {
      writer.uint32(26).string(message.path);
    }
    Object.entries(message.headers).forEach(([key, value]) => {
      CreateBucketFromZipRequest_HeadersEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateBucketFromZipRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateBucketFromZipRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.newBucketId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.zipUrl = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.path = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = CreateBucketFromZipRequest_HeadersEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.headers[entry4.key] = entry4.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateBucketFromZipRequest {
    return {
      newBucketId: isSet(object.newBucketId) ? globalThis.String(object.newBucketId) : "",
      zipUrl: isSet(object.zipUrl) ? globalThis.String(object.zipUrl) : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      headers: isObject(object.headers)
        ? Object.entries(object.headers).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: CreateBucketFromZipRequest): unknown {
    const obj: any = {};
    if (message.newBucketId !== "") {
      obj.newBucketId = message.newBucketId;
    }
    if (message.zipUrl !== "") {
      obj.zipUrl = message.zipUrl;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.headers) {
      const entries = Object.entries(message.headers);
      if (entries.length > 0) {
        obj.headers = {};
        entries.forEach(([k, v]) => {
          obj.headers[k] = v;
        });
      }
    }
    return obj;
  },

  create(base?: DeepPartial<CreateBucketFromZipRequest>): CreateBucketFromZipRequest {
    return CreateBucketFromZipRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateBucketFromZipRequest>): CreateBucketFromZipRequest {
    const message = createBaseCreateBucketFromZipRequest();
    message.newBucketId = object.newBucketId ?? "";
    message.zipUrl = object.zipUrl ?? "";
    message.path = object.path ?? "";
    message.headers = Object.entries(object.headers ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseCreateBucketFromZipRequest_HeadersEntry(): CreateBucketFromZipRequest_HeadersEntry {
  return { key: "", value: "" };
}

export const CreateBucketFromZipRequest_HeadersEntry: MessageFns<CreateBucketFromZipRequest_HeadersEntry> = {
  encode(message: CreateBucketFromZipRequest_HeadersEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateBucketFromZipRequest_HeadersEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateBucketFromZipRequest_HeadersEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateBucketFromZipRequest_HeadersEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CreateBucketFromZipRequest_HeadersEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateBucketFromZipRequest_HeadersEntry>): CreateBucketFromZipRequest_HeadersEntry {
    return CreateBucketFromZipRequest_HeadersEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateBucketFromZipRequest_HeadersEntry>): CreateBucketFromZipRequest_HeadersEntry {
    const message = createBaseCreateBucketFromZipRequest_HeadersEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseCreateBucketFromGithubRequest(): CreateBucketFromGithubRequest {
  return { newBucketId: "", owner: "", repo: "", path: "", ref: "", token: "" };
}

export const CreateBucketFromGithubRequest: MessageFns<CreateBucketFromGithubRequest> = {
  encode(message: CreateBucketFromGithubRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.newBucketId !== "") {
      writer.uint32(10).string(message.newBucketId);
    }
    if (message.owner !== "") {
      writer.uint32(18).string(message.owner);
    }
    if (message.repo !== "") {
      writer.uint32(26).string(message.repo);
    }
    if (message.path !== "") {
      writer.uint32(34).string(message.path);
    }
    if (message.ref !== "") {
      writer.uint32(42).string(message.ref);
    }
    if (message.token !== "") {
      writer.uint32(50).string(message.token);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateBucketFromGithubRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateBucketFromGithubRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.newBucketId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.owner = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.repo = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.path = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.ref = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.token = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateBucketFromGithubRequest {
    return {
      newBucketId: isSet(object.newBucketId) ? globalThis.String(object.newBucketId) : "",
      owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
      repo: isSet(object.repo) ? globalThis.String(object.repo) : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      ref: isSet(object.ref) ? globalThis.String(object.ref) : "",
      token: isSet(object.token) ? globalThis.String(object.token) : "",
    };
  },

  toJSON(message: CreateBucketFromGithubRequest): unknown {
    const obj: any = {};
    if (message.newBucketId !== "") {
      obj.newBucketId = message.newBucketId;
    }
    if (message.owner !== "") {
      obj.owner = message.owner;
    }
    if (message.repo !== "") {
      obj.repo = message.repo;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.ref !== "") {
      obj.ref = message.ref;
    }
    if (message.token !== "") {
      obj.token = message.token;
    }
    return obj;
  },

  create(base?: DeepPartial<CreateBucketFromGithubRequest>): CreateBucketFromGithubRequest {
    return CreateBucketFromGithubRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<CreateBucketFromGithubRequest>): CreateBucketFromGithubRequest {
    const message = createBaseCreateBucketFromGithubRequest();
    message.newBucketId = object.newBucketId ?? "";
    message.owner = object.owner ?? "";
    message.repo = object.repo ?? "";
    message.path = object.path ?? "";
    message.ref = object.ref ?? "";
    message.token = object.token ?? "";
    return message;
  },
};

function createBaseCreateBucketResponse(): CreateBucketResponse {
  return {};
}

export const CreateBucketResponse: MessageFns<CreateBucketResponse> = {
  encode(_: CreateBucketResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateBucketResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateBucketResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): CreateBucketResponse {
    return {};
  },

  toJSON(_: CreateBucketResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<CreateBucketResponse>): CreateBucketResponse {
    return CreateBucketResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<CreateBucketResponse>): CreateBucketResponse {
    const message = createBaseCreateBucketResponse();
    return message;
  },
};

function createBaseGetBucketTokenRequest(): GetBucketTokenRequest {
  return { bucketId: "", expiresInSeconds: Long.ZERO };
}

export const GetBucketTokenRequest: MessageFns<GetBucketTokenRequest> = {
  encode(message: GetBucketTokenRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bucketId !== "") {
      writer.uint32(10).string(message.bucketId);
    }
    if (!message.expiresInSeconds.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.expiresInSeconds.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBucketTokenRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBucketTokenRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bucketId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.expiresInSeconds = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBucketTokenRequest {
    return {
      bucketId: isSet(object.bucketId) ? globalThis.String(object.bucketId) : "",
      expiresInSeconds: isSet(object.expiresInSeconds) ? Long.fromValue(object.expiresInSeconds) : Long.ZERO,
    };
  },

  toJSON(message: GetBucketTokenRequest): unknown {
    const obj: any = {};
    if (message.bucketId !== "") {
      obj.bucketId = message.bucketId;
    }
    if (!message.expiresInSeconds.equals(Long.ZERO)) {
      obj.expiresInSeconds = (message.expiresInSeconds || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<GetBucketTokenRequest>): GetBucketTokenRequest {
    return GetBucketTokenRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetBucketTokenRequest>): GetBucketTokenRequest {
    const message = createBaseGetBucketTokenRequest();
    message.bucketId = object.bucketId ?? "";
    message.expiresInSeconds = (object.expiresInSeconds !== undefined && object.expiresInSeconds !== null)
      ? Long.fromValue(object.expiresInSeconds)
      : Long.ZERO;
    return message;
  },
};

function createBaseGetBucketTokenResponse(): GetBucketTokenResponse {
  return { token: "" };
}

export const GetBucketTokenResponse: MessageFns<GetBucketTokenResponse> = {
  encode(message: GetBucketTokenResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBucketTokenResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBucketTokenResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.token = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBucketTokenResponse {
    return { token: isSet(object.token) ? globalThis.String(object.token) : "" };
  },

  toJSON(message: GetBucketTokenResponse): unknown {
    const obj: any = {};
    if (message.token !== "") {
      obj.token = message.token;
    }
    return obj;
  },

  create(base?: DeepPartial<GetBucketTokenResponse>): GetBucketTokenResponse {
    return GetBucketTokenResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetBucketTokenResponse>): GetBucketTokenResponse {
    const message = createBaseGetBucketTokenResponse();
    message.token = object.token ?? "";
    return message;
  },
};

function createBaseGetBucketFileRequest(): GetBucketFileRequest {
  return { bucketId: "", path: "" };
}

export const GetBucketFileRequest: MessageFns<GetBucketFileRequest> = {
  encode(message: GetBucketFileRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bucketId !== "") {
      writer.uint32(10).string(message.bucketId);
    }
    if (message.path !== "") {
      writer.uint32(18).string(message.path);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBucketFileRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBucketFileRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bucketId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.path = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBucketFileRequest {
    return {
      bucketId: isSet(object.bucketId) ? globalThis.String(object.bucketId) : "",
      path: isSet(object.path) ? globalThis.String(object.path) : "",
    };
  },

  toJSON(message: GetBucketFileRequest): unknown {
    const obj: any = {};
    if (message.bucketId !== "") {
      obj.bucketId = message.bucketId;
    }
    if (message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },

  create(base?: DeepPartial<GetBucketFileRequest>): GetBucketFileRequest {
    return GetBucketFileRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetBucketFileRequest>): GetBucketFileRequest {
    const message = createBaseGetBucketFileRequest();
    message.bucketId = object.bucketId ?? "";
    message.path = object.path ?? "";
    return message;
  },
};

function createBaseGetBucketFileResponse(): GetBucketFileResponse {
  return { content: undefined };
}

export const GetBucketFileResponse: MessageFns<GetBucketFileResponse> = {
  encode(message: GetBucketFileResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.content !== undefined) {
      FileContent.encode(message.content, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBucketFileResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBucketFileResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.content = FileContent.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBucketFileResponse {
    return { content: isSet(object.content) ? FileContent.fromJSON(object.content) : undefined };
  },

  toJSON(message: GetBucketFileResponse): unknown {
    const obj: any = {};
    if (message.content !== undefined) {
      obj.content = FileContent.toJSON(message.content);
    }
    return obj;
  },

  create(base?: DeepPartial<GetBucketFileResponse>): GetBucketFileResponse {
    return GetBucketFileResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetBucketFileResponse>): GetBucketFileResponse {
    const message = createBaseGetBucketFileResponse();
    message.content = (object.content !== undefined && object.content !== null)
      ? FileContent.fromPartial(object.content)
      : undefined;
    return message;
  },
};

function createBaseGetBucketFilesRequest(): GetBucketFilesRequest {
  return { bucketId: "", prefix: "" };
}

export const GetBucketFilesRequest: MessageFns<GetBucketFilesRequest> = {
  encode(message: GetBucketFilesRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bucketId !== "") {
      writer.uint32(10).string(message.bucketId);
    }
    if (message.prefix !== "") {
      writer.uint32(18).string(message.prefix);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBucketFilesRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBucketFilesRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bucketId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.prefix = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBucketFilesRequest {
    return {
      bucketId: isSet(object.bucketId) ? globalThis.String(object.bucketId) : "",
      prefix: isSet(object.prefix) ? globalThis.String(object.prefix) : "",
    };
  },

  toJSON(message: GetBucketFilesRequest): unknown {
    const obj: any = {};
    if (message.bucketId !== "") {
      obj.bucketId = message.bucketId;
    }
    if (message.prefix !== "") {
      obj.prefix = message.prefix;
    }
    return obj;
  },

  create(base?: DeepPartial<GetBucketFilesRequest>): GetBucketFilesRequest {
    return GetBucketFilesRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetBucketFilesRequest>): GetBucketFilesRequest {
    const message = createBaseGetBucketFilesRequest();
    message.bucketId = object.bucketId ?? "";
    message.prefix = object.prefix ?? "";
    return message;
  },
};

function createBaseGetBucketFilesResponse(): GetBucketFilesResponse {
  return { files: [] };
}

export const GetBucketFilesResponse: MessageFns<GetBucketFilesResponse> = {
  encode(message: GetBucketFilesResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.files) {
      FileInfo.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBucketFilesResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBucketFilesResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.files.push(FileInfo.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBucketFilesResponse {
    return { files: globalThis.Array.isArray(object?.files) ? object.files.map((e: any) => FileInfo.fromJSON(e)) : [] };
  },

  toJSON(message: GetBucketFilesResponse): unknown {
    const obj: any = {};
    if (message.files?.length) {
      obj.files = message.files.map((e) => FileInfo.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GetBucketFilesResponse>): GetBucketFilesResponse {
    return GetBucketFilesResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetBucketFilesResponse>): GetBucketFilesResponse {
    const message = createBaseGetBucketFilesResponse();
    message.files = object.files?.map((e) => FileInfo.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetBucketFilesWithContentResponse(): GetBucketFilesWithContentResponse {
  return { files: [] };
}

export const GetBucketFilesWithContentResponse: MessageFns<GetBucketFilesWithContentResponse> = {
  encode(message: GetBucketFilesWithContentResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.files) {
      FileContent.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBucketFilesWithContentResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBucketFilesWithContentResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.files.push(FileContent.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBucketFilesWithContentResponse {
    return {
      files: globalThis.Array.isArray(object?.files) ? object.files.map((e: any) => FileContent.fromJSON(e)) : [],
    };
  },

  toJSON(message: GetBucketFilesWithContentResponse): unknown {
    const obj: any = {};
    if (message.files?.length) {
      obj.files = message.files.map((e) => FileContent.toJSON(e));
    }
    return obj;
  },

  create(base?: DeepPartial<GetBucketFilesWithContentResponse>): GetBucketFilesWithContentResponse {
    return GetBucketFilesWithContentResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetBucketFilesWithContentResponse>): GetBucketFilesWithContentResponse {
    const message = createBaseGetBucketFilesWithContentResponse();
    message.files = object.files?.map((e) => FileContent.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGetBucketFilesAsZipRequest(): GetBucketFilesAsZipRequest {
  return { bucketId: "", prefix: "" };
}

export const GetBucketFilesAsZipRequest: MessageFns<GetBucketFilesAsZipRequest> = {
  encode(message: GetBucketFilesAsZipRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.bucketId !== "") {
      writer.uint32(10).string(message.bucketId);
    }
    if (message.prefix !== "") {
      writer.uint32(18).string(message.prefix);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBucketFilesAsZipRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBucketFilesAsZipRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.bucketId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.prefix = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBucketFilesAsZipRequest {
    return {
      bucketId: isSet(object.bucketId) ? globalThis.String(object.bucketId) : "",
      prefix: isSet(object.prefix) ? globalThis.String(object.prefix) : "",
    };
  },

  toJSON(message: GetBucketFilesAsZipRequest): unknown {
    const obj: any = {};
    if (message.bucketId !== "") {
      obj.bucketId = message.bucketId;
    }
    if (message.prefix !== "") {
      obj.prefix = message.prefix;
    }
    return obj;
  },

  create(base?: DeepPartial<GetBucketFilesAsZipRequest>): GetBucketFilesAsZipRequest {
    return GetBucketFilesAsZipRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetBucketFilesAsZipRequest>): GetBucketFilesAsZipRequest {
    const message = createBaseGetBucketFilesAsZipRequest();
    message.bucketId = object.bucketId ?? "";
    message.prefix = object.prefix ?? "";
    return message;
  },
};

function createBaseGetBucketFilesAsZipResponse(): GetBucketFilesAsZipResponse {
  return { downloadUrl: "", expiresAt: Long.ZERO };
}

export const GetBucketFilesAsZipResponse: MessageFns<GetBucketFilesAsZipResponse> = {
  encode(message: GetBucketFilesAsZipResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.downloadUrl !== "") {
      writer.uint32(10).string(message.downloadUrl);
    }
    if (!message.expiresAt.equals(Long.ZERO)) {
      writer.uint32(16).int64(message.expiresAt.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetBucketFilesAsZipResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetBucketFilesAsZipResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.downloadUrl = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.expiresAt = Long.fromString(reader.int64().toString());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetBucketFilesAsZipResponse {
    return {
      downloadUrl: isSet(object.downloadUrl) ? globalThis.String(object.downloadUrl) : "",
      expiresAt: isSet(object.expiresAt) ? Long.fromValue(object.expiresAt) : Long.ZERO,
    };
  },

  toJSON(message: GetBucketFilesAsZipResponse): unknown {
    const obj: any = {};
    if (message.downloadUrl !== "") {
      obj.downloadUrl = message.downloadUrl;
    }
    if (!message.expiresAt.equals(Long.ZERO)) {
      obj.expiresAt = (message.expiresAt || Long.ZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<GetBucketFilesAsZipResponse>): GetBucketFilesAsZipResponse {
    return GetBucketFilesAsZipResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetBucketFilesAsZipResponse>): GetBucketFilesAsZipResponse {
    const message = createBaseGetBucketFilesAsZipResponse();
    message.downloadUrl = object.downloadUrl ?? "";
    message.expiresAt = (object.expiresAt !== undefined && object.expiresAt !== null)
      ? Long.fromValue(object.expiresAt)
      : Long.ZERO;
    return message;
  },
};

export type CodeBucketService = typeof CodeBucketService;
export const CodeBucketService = {
  cloneBucket: {
    path: "/rpc.rpc.CodeBucket/CloneBucket",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CloneBucketRequest): Buffer => Buffer.from(CloneBucketRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CloneBucketRequest => CloneBucketRequest.decode(value),
    responseSerialize: (value: CreateBucketResponse): Buffer =>
      Buffer.from(CreateBucketResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): CreateBucketResponse => CreateBucketResponse.decode(value),
  },
  createBucketFromZip: {
    path: "/rpc.rpc.CodeBucket/CreateBucketFromZip",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateBucketFromZipRequest): Buffer =>
      Buffer.from(CreateBucketFromZipRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateBucketFromZipRequest => CreateBucketFromZipRequest.decode(value),
    responseSerialize: (value: CreateBucketResponse): Buffer =>
      Buffer.from(CreateBucketResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): CreateBucketResponse => CreateBucketResponse.decode(value),
  },
  createBucketFromGithub: {
    path: "/rpc.rpc.CodeBucket/CreateBucketFromGithub",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateBucketFromGithubRequest): Buffer =>
      Buffer.from(CreateBucketFromGithubRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): CreateBucketFromGithubRequest => CreateBucketFromGithubRequest.decode(value),
    responseSerialize: (value: CreateBucketResponse): Buffer =>
      Buffer.from(CreateBucketResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): CreateBucketResponse => CreateBucketResponse.decode(value),
  },
  getBucketToken: {
    path: "/rpc.rpc.CodeBucket/GetBucketToken",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetBucketTokenRequest): Buffer =>
      Buffer.from(GetBucketTokenRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetBucketTokenRequest => GetBucketTokenRequest.decode(value),
    responseSerialize: (value: GetBucketTokenResponse): Buffer =>
      Buffer.from(GetBucketTokenResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetBucketTokenResponse => GetBucketTokenResponse.decode(value),
  },
  getBucketFile: {
    path: "/rpc.rpc.CodeBucket/GetBucketFile",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetBucketFileRequest): Buffer => Buffer.from(GetBucketFileRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetBucketFileRequest => GetBucketFileRequest.decode(value),
    responseSerialize: (value: GetBucketFileResponse): Buffer =>
      Buffer.from(GetBucketFileResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetBucketFileResponse => GetBucketFileResponse.decode(value),
  },
  getBucketFiles: {
    path: "/rpc.rpc.CodeBucket/GetBucketFiles",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetBucketFilesRequest): Buffer =>
      Buffer.from(GetBucketFilesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetBucketFilesRequest => GetBucketFilesRequest.decode(value),
    responseSerialize: (value: GetBucketFilesResponse): Buffer =>
      Buffer.from(GetBucketFilesResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetBucketFilesResponse => GetBucketFilesResponse.decode(value),
  },
  getBucketFilesWithContent: {
    path: "/rpc.rpc.CodeBucket/GetBucketFilesWithContent",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetBucketFilesRequest): Buffer =>
      Buffer.from(GetBucketFilesRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetBucketFilesRequest => GetBucketFilesRequest.decode(value),
    responseSerialize: (value: GetBucketFilesWithContentResponse): Buffer =>
      Buffer.from(GetBucketFilesWithContentResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetBucketFilesWithContentResponse =>
      GetBucketFilesWithContentResponse.decode(value),
  },
  getBucketFilesAsZip: {
    path: "/rpc.rpc.CodeBucket/GetBucketFilesAsZip",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetBucketFilesAsZipRequest): Buffer =>
      Buffer.from(GetBucketFilesAsZipRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetBucketFilesAsZipRequest => GetBucketFilesAsZipRequest.decode(value),
    responseSerialize: (value: GetBucketFilesAsZipResponse): Buffer =>
      Buffer.from(GetBucketFilesAsZipResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetBucketFilesAsZipResponse => GetBucketFilesAsZipResponse.decode(value),
  },
} as const;

export interface CodeBucketServer extends UntypedServiceImplementation {
  cloneBucket: handleUnaryCall<CloneBucketRequest, CreateBucketResponse>;
  createBucketFromZip: handleUnaryCall<CreateBucketFromZipRequest, CreateBucketResponse>;
  createBucketFromGithub: handleUnaryCall<CreateBucketFromGithubRequest, CreateBucketResponse>;
  getBucketToken: handleUnaryCall<GetBucketTokenRequest, GetBucketTokenResponse>;
  getBucketFile: handleUnaryCall<GetBucketFileRequest, GetBucketFileResponse>;
  getBucketFiles: handleUnaryCall<GetBucketFilesRequest, GetBucketFilesResponse>;
  getBucketFilesWithContent: handleUnaryCall<GetBucketFilesRequest, GetBucketFilesWithContentResponse>;
  getBucketFilesAsZip: handleUnaryCall<GetBucketFilesAsZipRequest, GetBucketFilesAsZipResponse>;
}

export interface CodeBucketClient extends Client {
  cloneBucket(
    request: CloneBucketRequest,
    callback: (error: ServiceError | null, response: CreateBucketResponse) => void,
  ): ClientUnaryCall;
  cloneBucket(
    request: CloneBucketRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CreateBucketResponse) => void,
  ): ClientUnaryCall;
  cloneBucket(
    request: CloneBucketRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CreateBucketResponse) => void,
  ): ClientUnaryCall;
  createBucketFromZip(
    request: CreateBucketFromZipRequest,
    callback: (error: ServiceError | null, response: CreateBucketResponse) => void,
  ): ClientUnaryCall;
  createBucketFromZip(
    request: CreateBucketFromZipRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CreateBucketResponse) => void,
  ): ClientUnaryCall;
  createBucketFromZip(
    request: CreateBucketFromZipRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CreateBucketResponse) => void,
  ): ClientUnaryCall;
  createBucketFromGithub(
    request: CreateBucketFromGithubRequest,
    callback: (error: ServiceError | null, response: CreateBucketResponse) => void,
  ): ClientUnaryCall;
  createBucketFromGithub(
    request: CreateBucketFromGithubRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CreateBucketResponse) => void,
  ): ClientUnaryCall;
  createBucketFromGithub(
    request: CreateBucketFromGithubRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CreateBucketResponse) => void,
  ): ClientUnaryCall;
  getBucketToken(
    request: GetBucketTokenRequest,
    callback: (error: ServiceError | null, response: GetBucketTokenResponse) => void,
  ): ClientUnaryCall;
  getBucketToken(
    request: GetBucketTokenRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetBucketTokenResponse) => void,
  ): ClientUnaryCall;
  getBucketToken(
    request: GetBucketTokenRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetBucketTokenResponse) => void,
  ): ClientUnaryCall;
  getBucketFile(
    request: GetBucketFileRequest,
    callback: (error: ServiceError | null, response: GetBucketFileResponse) => void,
  ): ClientUnaryCall;
  getBucketFile(
    request: GetBucketFileRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetBucketFileResponse) => void,
  ): ClientUnaryCall;
  getBucketFile(
    request: GetBucketFileRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetBucketFileResponse) => void,
  ): ClientUnaryCall;
  getBucketFiles(
    request: GetBucketFilesRequest,
    callback: (error: ServiceError | null, response: GetBucketFilesResponse) => void,
  ): ClientUnaryCall;
  getBucketFiles(
    request: GetBucketFilesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetBucketFilesResponse) => void,
  ): ClientUnaryCall;
  getBucketFiles(
    request: GetBucketFilesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetBucketFilesResponse) => void,
  ): ClientUnaryCall;
  getBucketFilesWithContent(
    request: GetBucketFilesRequest,
    callback: (error: ServiceError | null, response: GetBucketFilesWithContentResponse) => void,
  ): ClientUnaryCall;
  getBucketFilesWithContent(
    request: GetBucketFilesRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetBucketFilesWithContentResponse) => void,
  ): ClientUnaryCall;
  getBucketFilesWithContent(
    request: GetBucketFilesRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetBucketFilesWithContentResponse) => void,
  ): ClientUnaryCall;
  getBucketFilesAsZip(
    request: GetBucketFilesAsZipRequest,
    callback: (error: ServiceError | null, response: GetBucketFilesAsZipResponse) => void,
  ): ClientUnaryCall;
  getBucketFilesAsZip(
    request: GetBucketFilesAsZipRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetBucketFilesAsZipResponse) => void,
  ): ClientUnaryCall;
  getBucketFilesAsZip(
    request: GetBucketFilesAsZipRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetBucketFilesAsZipResponse) => void,
  ): ClientUnaryCall;
}

export const CodeBucketClient = makeGenericClientConstructor(CodeBucketService, "rpc.rpc.CodeBucket") as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): CodeBucketClient;
  service: typeof CodeBucketService;
  serviceName: string;
};

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
  } else {
    const bin = globalThis.atob(b64);
    const arr = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i);
    }
    return arr;
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString("base64");
  } else {
    const bin: string[] = [];
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte));
    });
    return globalThis.btoa(bin.join(""));
  }
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
