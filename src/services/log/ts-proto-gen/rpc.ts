// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.5
//   protoc               v6.31.1
// source: rpc.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  type ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  type Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";
import Long from "long";

export const protobufPackage = "rpc.rpc";

export enum ListPaginationOrder {
  list_cursor_order_asc = 0,
  list_cursor_order_desc = 1,
  UNRECOGNIZED = -1,
}

export function listPaginationOrderFromJSON(object: any): ListPaginationOrder {
  switch (object) {
    case 0:
    case "list_cursor_order_asc":
      return ListPaginationOrder.list_cursor_order_asc;
    case 1:
    case "list_cursor_order_desc":
      return ListPaginationOrder.list_cursor_order_desc;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ListPaginationOrder.UNRECOGNIZED;
  }
}

export function listPaginationOrderToJSON(object: ListPaginationOrder): string {
  switch (object) {
    case ListPaginationOrder.list_cursor_order_asc:
      return "list_cursor_order_asc";
    case ListPaginationOrder.list_cursor_order_desc:
      return "list_cursor_order_desc";
    case ListPaginationOrder.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface ListPagination {
  afterId: string;
  beforeId: string;
  limit: number;
  order: ListPaginationOrder;
}

export interface LogEntry {
  entityId: string;
  entityType: string;
  instanceId: string;
  payload: string;
  timestamp: Long;
}

export interface IngestLogRequest {
  entityId: string;
  entityType: string;
  instanceId: string;
  payload: string;
  timestamp: Long;
}

export interface IngestLogResponse {
}

export interface ListLogsRequest {
  entityType: string;
  entityIds: string[];
  instanceIds: string[];
}

export interface ListLogsResponse {
  logs: LogEntry[];
  pagination: ListPagination | undefined;
}

export interface GetLogRequest {
  entityId: string;
  entityType: string;
  instanceId?: string | undefined;
}

export interface GetLogResponse {
  log: LogEntry | undefined;
}

function createBaseListPagination(): ListPagination {
  return { afterId: "", beforeId: "", limit: 0, order: 0 };
}

export const ListPagination: MessageFns<ListPagination> = {
  encode(message: ListPagination, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.afterId !== "") {
      writer.uint32(10).string(message.afterId);
    }
    if (message.beforeId !== "") {
      writer.uint32(18).string(message.beforeId);
    }
    if (message.limit !== 0) {
      writer.uint32(24).int32(message.limit);
    }
    if (message.order !== 0) {
      writer.uint32(32).int32(message.order);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListPagination {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListPagination();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.afterId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.beforeId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.order = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListPagination {
    return {
      afterId: isSet(object.afterId) ? globalThis.String(object.afterId) : "",
      beforeId: isSet(object.beforeId) ? globalThis.String(object.beforeId) : "",
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      order: isSet(object.order) ? listPaginationOrderFromJSON(object.order) : 0,
    };
  },

  toJSON(message: ListPagination): unknown {
    const obj: any = {};
    if (message.afterId !== "") {
      obj.afterId = message.afterId;
    }
    if (message.beforeId !== "") {
      obj.beforeId = message.beforeId;
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.order !== 0) {
      obj.order = listPaginationOrderToJSON(message.order);
    }
    return obj;
  },

  create(base?: DeepPartial<ListPagination>): ListPagination {
    return ListPagination.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListPagination>): ListPagination {
    const message = createBaseListPagination();
    message.afterId = object.afterId ?? "";
    message.beforeId = object.beforeId ?? "";
    message.limit = object.limit ?? 0;
    message.order = object.order ?? 0;
    return message;
  },
};

function createBaseLogEntry(): LogEntry {
  return { entityId: "", entityType: "", instanceId: "", payload: "", timestamp: Long.UZERO };
}

export const LogEntry: MessageFns<LogEntry> = {
  encode(message: LogEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.entityId !== "") {
      writer.uint32(10).string(message.entityId);
    }
    if (message.entityType !== "") {
      writer.uint32(18).string(message.entityType);
    }
    if (message.instanceId !== "") {
      writer.uint32(26).string(message.instanceId);
    }
    if (message.payload !== "") {
      writer.uint32(42).string(message.payload);
    }
    if (!message.timestamp.equals(Long.UZERO)) {
      writer.uint32(48).uint64(message.timestamp.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLogEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.entityId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.entityType = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.instanceId = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.payload = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 48) {
            break;
          }

          message.timestamp = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LogEntry {
    return {
      entityId: isSet(object.entityId) ? globalThis.String(object.entityId) : "",
      entityType: isSet(object.entityType) ? globalThis.String(object.entityType) : "",
      instanceId: isSet(object.instanceId) ? globalThis.String(object.instanceId) : "",
      payload: isSet(object.payload) ? globalThis.String(object.payload) : "",
      timestamp: isSet(object.timestamp) ? Long.fromValue(object.timestamp) : Long.UZERO,
    };
  },

  toJSON(message: LogEntry): unknown {
    const obj: any = {};
    if (message.entityId !== "") {
      obj.entityId = message.entityId;
    }
    if (message.entityType !== "") {
      obj.entityType = message.entityType;
    }
    if (message.instanceId !== "") {
      obj.instanceId = message.instanceId;
    }
    if (message.payload !== "") {
      obj.payload = message.payload;
    }
    if (!message.timestamp.equals(Long.UZERO)) {
      obj.timestamp = (message.timestamp || Long.UZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<LogEntry>): LogEntry {
    return LogEntry.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<LogEntry>): LogEntry {
    const message = createBaseLogEntry();
    message.entityId = object.entityId ?? "";
    message.entityType = object.entityType ?? "";
    message.instanceId = object.instanceId ?? "";
    message.payload = object.payload ?? "";
    message.timestamp = (object.timestamp !== undefined && object.timestamp !== null)
      ? Long.fromValue(object.timestamp)
      : Long.UZERO;
    return message;
  },
};

function createBaseIngestLogRequest(): IngestLogRequest {
  return { entityId: "", entityType: "", instanceId: "", payload: "", timestamp: Long.UZERO };
}

export const IngestLogRequest: MessageFns<IngestLogRequest> = {
  encode(message: IngestLogRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.entityId !== "") {
      writer.uint32(10).string(message.entityId);
    }
    if (message.entityType !== "") {
      writer.uint32(18).string(message.entityType);
    }
    if (message.instanceId !== "") {
      writer.uint32(26).string(message.instanceId);
    }
    if (message.payload !== "") {
      writer.uint32(34).string(message.payload);
    }
    if (!message.timestamp.equals(Long.UZERO)) {
      writer.uint32(40).uint64(message.timestamp.toString());
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IngestLogRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIngestLogRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.entityId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.entityType = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.instanceId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.payload = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.timestamp = Long.fromString(reader.uint64().toString(), true);
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IngestLogRequest {
    return {
      entityId: isSet(object.entityId) ? globalThis.String(object.entityId) : "",
      entityType: isSet(object.entityType) ? globalThis.String(object.entityType) : "",
      instanceId: isSet(object.instanceId) ? globalThis.String(object.instanceId) : "",
      payload: isSet(object.payload) ? globalThis.String(object.payload) : "",
      timestamp: isSet(object.timestamp) ? Long.fromValue(object.timestamp) : Long.UZERO,
    };
  },

  toJSON(message: IngestLogRequest): unknown {
    const obj: any = {};
    if (message.entityId !== "") {
      obj.entityId = message.entityId;
    }
    if (message.entityType !== "") {
      obj.entityType = message.entityType;
    }
    if (message.instanceId !== "") {
      obj.instanceId = message.instanceId;
    }
    if (message.payload !== "") {
      obj.payload = message.payload;
    }
    if (!message.timestamp.equals(Long.UZERO)) {
      obj.timestamp = (message.timestamp || Long.UZERO).toString();
    }
    return obj;
  },

  create(base?: DeepPartial<IngestLogRequest>): IngestLogRequest {
    return IngestLogRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<IngestLogRequest>): IngestLogRequest {
    const message = createBaseIngestLogRequest();
    message.entityId = object.entityId ?? "";
    message.entityType = object.entityType ?? "";
    message.instanceId = object.instanceId ?? "";
    message.payload = object.payload ?? "";
    message.timestamp = (object.timestamp !== undefined && object.timestamp !== null)
      ? Long.fromValue(object.timestamp)
      : Long.UZERO;
    return message;
  },
};

function createBaseIngestLogResponse(): IngestLogResponse {
  return {};
}

export const IngestLogResponse: MessageFns<IngestLogResponse> = {
  encode(_: IngestLogResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IngestLogResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIngestLogResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): IngestLogResponse {
    return {};
  },

  toJSON(_: IngestLogResponse): unknown {
    const obj: any = {};
    return obj;
  },

  create(base?: DeepPartial<IngestLogResponse>): IngestLogResponse {
    return IngestLogResponse.fromPartial(base ?? {});
  },
  fromPartial(_: DeepPartial<IngestLogResponse>): IngestLogResponse {
    const message = createBaseIngestLogResponse();
    return message;
  },
};

function createBaseListLogsRequest(): ListLogsRequest {
  return { entityType: "", entityIds: [], instanceIds: [] };
}

export const ListLogsRequest: MessageFns<ListLogsRequest> = {
  encode(message: ListLogsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.entityType !== "") {
      writer.uint32(18).string(message.entityType);
    }
    for (const v of message.entityIds) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.instanceIds) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListLogsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListLogsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.entityType = reader.string();
          continue;
        }
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.entityIds.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.instanceIds.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListLogsRequest {
    return {
      entityType: isSet(object.entityType) ? globalThis.String(object.entityType) : "",
      entityIds: globalThis.Array.isArray(object?.entityIds)
        ? object.entityIds.map((e: any) => globalThis.String(e))
        : [],
      instanceIds: globalThis.Array.isArray(object?.instanceIds)
        ? object.instanceIds.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: ListLogsRequest): unknown {
    const obj: any = {};
    if (message.entityType !== "") {
      obj.entityType = message.entityType;
    }
    if (message.entityIds?.length) {
      obj.entityIds = message.entityIds;
    }
    if (message.instanceIds?.length) {
      obj.instanceIds = message.instanceIds;
    }
    return obj;
  },

  create(base?: DeepPartial<ListLogsRequest>): ListLogsRequest {
    return ListLogsRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListLogsRequest>): ListLogsRequest {
    const message = createBaseListLogsRequest();
    message.entityType = object.entityType ?? "";
    message.entityIds = object.entityIds?.map((e) => e) || [];
    message.instanceIds = object.instanceIds?.map((e) => e) || [];
    return message;
  },
};

function createBaseListLogsResponse(): ListLogsResponse {
  return { logs: [], pagination: undefined };
}

export const ListLogsResponse: MessageFns<ListLogsResponse> = {
  encode(message: ListLogsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.logs) {
      LogEntry.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.pagination !== undefined) {
      ListPagination.encode(message.pagination, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ListLogsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseListLogsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.logs.push(LogEntry.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.pagination = ListPagination.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ListLogsResponse {
    return {
      logs: globalThis.Array.isArray(object?.logs) ? object.logs.map((e: any) => LogEntry.fromJSON(e)) : [],
      pagination: isSet(object.pagination) ? ListPagination.fromJSON(object.pagination) : undefined,
    };
  },

  toJSON(message: ListLogsResponse): unknown {
    const obj: any = {};
    if (message.logs?.length) {
      obj.logs = message.logs.map((e) => LogEntry.toJSON(e));
    }
    if (message.pagination !== undefined) {
      obj.pagination = ListPagination.toJSON(message.pagination);
    }
    return obj;
  },

  create(base?: DeepPartial<ListLogsResponse>): ListLogsResponse {
    return ListLogsResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<ListLogsResponse>): ListLogsResponse {
    const message = createBaseListLogsResponse();
    message.logs = object.logs?.map((e) => LogEntry.fromPartial(e)) || [];
    message.pagination = (object.pagination !== undefined && object.pagination !== null)
      ? ListPagination.fromPartial(object.pagination)
      : undefined;
    return message;
  },
};

function createBaseGetLogRequest(): GetLogRequest {
  return { entityId: "", entityType: "", instanceId: undefined };
}

export const GetLogRequest: MessageFns<GetLogRequest> = {
  encode(message: GetLogRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.entityId !== "") {
      writer.uint32(10).string(message.entityId);
    }
    if (message.entityType !== "") {
      writer.uint32(18).string(message.entityType);
    }
    if (message.instanceId !== undefined) {
      writer.uint32(26).string(message.instanceId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetLogRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLogRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.entityId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.entityType = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.instanceId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetLogRequest {
    return {
      entityId: isSet(object.entityId) ? globalThis.String(object.entityId) : "",
      entityType: isSet(object.entityType) ? globalThis.String(object.entityType) : "",
      instanceId: isSet(object.instanceId) ? globalThis.String(object.instanceId) : undefined,
    };
  },

  toJSON(message: GetLogRequest): unknown {
    const obj: any = {};
    if (message.entityId !== "") {
      obj.entityId = message.entityId;
    }
    if (message.entityType !== "") {
      obj.entityType = message.entityType;
    }
    if (message.instanceId !== undefined) {
      obj.instanceId = message.instanceId;
    }
    return obj;
  },

  create(base?: DeepPartial<GetLogRequest>): GetLogRequest {
    return GetLogRequest.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetLogRequest>): GetLogRequest {
    const message = createBaseGetLogRequest();
    message.entityId = object.entityId ?? "";
    message.entityType = object.entityType ?? "";
    message.instanceId = object.instanceId ?? undefined;
    return message;
  },
};

function createBaseGetLogResponse(): GetLogResponse {
  return { log: undefined };
}

export const GetLogResponse: MessageFns<GetLogResponse> = {
  encode(message: GetLogResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.log !== undefined) {
      LogEntry.encode(message.log, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetLogResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetLogResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.log = LogEntry.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetLogResponse {
    return { log: isSet(object.log) ? LogEntry.fromJSON(object.log) : undefined };
  },

  toJSON(message: GetLogResponse): unknown {
    const obj: any = {};
    if (message.log !== undefined) {
      obj.log = LogEntry.toJSON(message.log);
    }
    return obj;
  },

  create(base?: DeepPartial<GetLogResponse>): GetLogResponse {
    return GetLogResponse.fromPartial(base ?? {});
  },
  fromPartial(object: DeepPartial<GetLogResponse>): GetLogResponse {
    const message = createBaseGetLogResponse();
    message.log = (object.log !== undefined && object.log !== null) ? LogEntry.fromPartial(object.log) : undefined;
    return message;
  },
};

export type LogServiceService = typeof LogServiceService;
export const LogServiceService = {
  ingestLog: {
    path: "/rpc.rpc.LogService/IngestLog",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: IngestLogRequest): Buffer => Buffer.from(IngestLogRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): IngestLogRequest => IngestLogRequest.decode(value),
    responseSerialize: (value: IngestLogResponse): Buffer => Buffer.from(IngestLogResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): IngestLogResponse => IngestLogResponse.decode(value),
  },
  listLogs: {
    path: "/rpc.rpc.LogService/ListLogs",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ListLogsRequest): Buffer => Buffer.from(ListLogsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): ListLogsRequest => ListLogsRequest.decode(value),
    responseSerialize: (value: ListLogsResponse): Buffer => Buffer.from(ListLogsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): ListLogsResponse => ListLogsResponse.decode(value),
  },
  getLog: {
    path: "/rpc.rpc.LogService/GetLog",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetLogRequest): Buffer => Buffer.from(GetLogRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer): GetLogRequest => GetLogRequest.decode(value),
    responseSerialize: (value: GetLogResponse): Buffer => Buffer.from(GetLogResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer): GetLogResponse => GetLogResponse.decode(value),
  },
} as const;

export interface LogServiceServer extends UntypedServiceImplementation {
  ingestLog: handleUnaryCall<IngestLogRequest, IngestLogResponse>;
  listLogs: handleUnaryCall<ListLogsRequest, ListLogsResponse>;
  getLog: handleUnaryCall<GetLogRequest, GetLogResponse>;
}

export interface LogServiceClient extends Client {
  ingestLog(
    request: IngestLogRequest,
    callback: (error: ServiceError | null, response: IngestLogResponse) => void,
  ): ClientUnaryCall;
  ingestLog(
    request: IngestLogRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: IngestLogResponse) => void,
  ): ClientUnaryCall;
  ingestLog(
    request: IngestLogRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: IngestLogResponse) => void,
  ): ClientUnaryCall;
  listLogs(
    request: ListLogsRequest,
    callback: (error: ServiceError | null, response: ListLogsResponse) => void,
  ): ClientUnaryCall;
  listLogs(
    request: ListLogsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ListLogsResponse) => void,
  ): ClientUnaryCall;
  listLogs(
    request: ListLogsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ListLogsResponse) => void,
  ): ClientUnaryCall;
  getLog(
    request: GetLogRequest,
    callback: (error: ServiceError | null, response: GetLogResponse) => void,
  ): ClientUnaryCall;
  getLog(
    request: GetLogRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetLogResponse) => void,
  ): ClientUnaryCall;
  getLog(
    request: GetLogRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetLogResponse) => void,
  ): ClientUnaryCall;
}

export const LogServiceClient = makeGenericClientConstructor(LogServiceService, "rpc.rpc.LogService") as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): LogServiceClient;
  service: typeof LogServiceService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends Long ? string | number | Long : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create(base?: DeepPartial<T>): T;
  fromPartial(object: DeepPartial<T>): T;
}
